<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Java,">










<meta name="description" content="关于hexo的一些常用命令">
<meta name="keywords" content="Java">
<meta property="og:type" content="article">
<meta property="og:title" content="Java核心技术一">
<meta property="og:url" content="http://yoursite.com/2019/09/07/Java/index.html">
<meta property="og:site_name" content="shiysin">
<meta property="og:description" content="关于hexo的一些常用命令">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="https://i.imgur.com/zuqNweB.png">
<meta property="og:image" content="https://i.imgur.com/zYOolzB.jpg">
<meta property="og:image" content="https://i.imgur.com/evpmlPf.jpg">
<meta property="og:image" content="https://i.imgur.com/9PmF24I.jpg">
<meta property="og:image" content="https://i.imgur.com/Q6yC7i7.gif">
<meta property="og:image" content="https://i.imgur.com/qYlG4pZ.jpg">
<meta property="og:image" content="https://i.imgur.com/dRnCbSO.jpg">
<meta property="og:image" content="https://i.imgur.com/A3k1iy6.png">
<meta property="og:image" content="https://i.imgur.com/3Nd4DC6.png">
<meta property="og:image" content="https://i.imgur.com/AddxEF1.png">
<meta property="og:updated_time" content="2019-09-07T09:24:53.596Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Java核心技术一">
<meta name="twitter:description" content="关于hexo的一些常用命令">
<meta name="twitter:image" content="https://i.imgur.com/zuqNweB.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2019/09/07/Java/">





  <title>Java核心技术一 | shiysin</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">shiysin</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/09/07/Java/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="shiysin">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="shiysin">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Java核心技术一</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-09-07T18:35:49+08:00">
                2019-09-07
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          
              <div class="post-description">
                  关于hexo的一些常用命令
              </div>
          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h4 id="1-数据类型"><a href="#1-数据类型" class="headerlink" title="1.数据类型"></a><font color="red">1.数据类型</font></h4><h5 id="1-1-整形"><a href="#1-1-整形" class="headerlink" title="1.1 整形"></a>1.1 整形</h5><p><img src="https://i.imgur.com/zuqNweB.png" alt></p>
<ul>
<li>long类型后可加后缀&nbsp;”L”或”l”&nbsp;表示</li>
<li>二进制可加前缀&nbsp;”0b”或”0B”&nbsp;表示</li>
<li>八进制可加前缀&nbsp;”0”&nbsp;表示</li>
<li>十六进制可加前缀&nbsp;”0x”或”0X”表示</li>
<li>Java 7开始可为数字字面量加下划线使之更易读：1_000_000_000,编译器会去除<blockquote>
<p><strong>Java中没有任何无符号形式的整形</strong></p>
</blockquote>
<h5 id="1-2-浮点类型"><a href="#1-2-浮点类型" class="headerlink" title="1.2 浮点类型"></a>1.2 浮点类型</h5><table>
<thead>
<tr>
<th>类型</th>
<th align="center">存储需求</th>
<th align="left">取值范围</th>
</tr>
</thead>
<tbody><tr>
<td>float</td>
<td align="center">4字节</td>
<td align="left">大约3.402 823 47E+38F&nbsp;&nbsp;(有效位数为6~7位)</td>
</tr>
<tr>
<td>double</td>
<td align="center">8字节</td>
<td align="left">大约1.797 693 134 862 315 70E+308 &nbsp;(有效位数为15位)</td>
</tr>
</tbody></table>
</li>
<li>double表示双精度，一般都采用double类型，除非需要单精度的库或需要存储大量数据</li>
<li>float类型后加后缀&nbsp;”F”或”f”&nbsp;表示；无后缀的默认为double类型<blockquote>
<p>可用十六进制表示浮点数值，用p表示指数，而不是e</p>
</blockquote>
</li>
</ul>
<p>下面是表示溢出和出错情况的三个特殊的浮点数值&nbsp;(实际开发中很少用到)：</p>
<table>
<thead>
<tr>
<th>Double.POSITIVE_INFINITY</th>
<th>Double.NEGATIVE_INFINITY</th>
<th align="left">Double.NaN</th>
</tr>
</thead>
<tbody><tr>
<td>正无穷大</td>
<td>负无穷大</td>
<td align="left">NaN(不是一个数字)</td>
</tr>
</tbody></table>
<blockquote>
<p>可以使用Double.isNaN方法检查是不是一个数字</p>
</blockquote>
<h5 id="1-3char-类型"><a href="#1-3char-类型" class="headerlink" title="1.3char 类型"></a>1.3char 类型</h5><ul>
<li>表示单个字符；也可以用一个或两个char表示Unicode字符</li>
</ul>
<p><strong>特殊字符的转义序列:</strong></p>
<table>
<thead>
<tr>
<th align="center">转义序列</th>
<th align="center">名称</th>
<th align="center">Unicode值</th>
</tr>
</thead>
<tbody><tr>
<td align="center">\b</td>
<td align="center">退格</td>
<td align="center">\u0008</td>
</tr>
<tr>
<td align="center">\t</td>
<td align="center">制表</td>
<td align="center">\u0009</td>
</tr>
<tr>
<td align="center">\n</td>
<td align="center">换行</td>
<td align="center">\u000a</td>
</tr>
<tr>
<td align="center">\r</td>
<td align="center">回车</td>
<td align="center">\u000d</td>
</tr>
<tr>
<td align="center">\‘’</td>
<td align="center">双引号</td>
<td align="center">\u0022</td>
</tr>
<tr>
<td align="center">\‘</td>
<td align="center">单引号</td>
<td align="center">\u0027</td>
</tr>
<tr>
<td align="center">\\</td>
<td align="center">反斜杠</td>
<td align="center">\u005c</td>
</tr>
</tbody></table>
<blockquote>
<p><strong>Unicode转义序列会在解析代码之前得到处理</strong></p>
</blockquote>
<h5 id="1-4-boolean类型"><a href="#1-4-boolean类型" class="headerlink" title="1.4 boolean类型"></a>1.4 boolean类型</h5><ul>
<li>boolean类型有两个值：true、false</li>
<li>整形值和布尔值之间不能进行相互转换<h4 id="2-变量"><a href="#2-变量" class="headerlink" title="2. 变量"></a><font color="red">2. 变量</font></h4></li>
<li>变量名必须是一个以字母开头 并由字母或数字构成的序列，字母包括Unicode字符</li>
<li>可以使用Character类的isJavaIdentifierStart和isJavaIdentifierPart方法来检查是否为Unicode字符<h5 id="2-1-常量"><a href="#2-1-常量" class="headerlink" title="2.1 常量"></a>2.1 常量</h5></li>
<li>常量用关键字 <strong>final</strong> 表示，常量名全大写</li>
<li><strong>final</strong> 表示这个变量只能被赋值一次，而后不能更改</li>
<li><strong>类常量</strong>：可以在一个类的多个方法中使用，定义在<strong>main</strong>方法外部，可以使用关键字<strong>static final</strong>表示<h4 id="3-运算符"><a href="#3-运算符" class="headerlink" title="3. 运算符"></a><font color="red">3. 运算符</font></h4></li>
<li>整数被0除将会产生异常，<strong>浮点数</strong>被0除将会得到 <strong>无穷大</strong> 或 <strong>NaN</strong> 的结果<h5 id="3-1-Math数学函数与常量"><a href="#3-1-Math数学函数与常量" class="headerlink" title="3.1 Math数学函数与常量"></a>3.1 Math数学函数与常量</h5></li>
<li>sqrt(x)：平方根</li>
<li>pow(x, a):乘方</li>
<li>Math.PI:</li>
<li>Math.e:e常量的近似值  </li>
<li>floor: 返回不大于的最大整数</li>
<li>round: 表示“四舍五入”，算法为Math.floor(x+0.5)，即将原来的数字加上0.5后再向下取整。（正数小数点后大于5则进位；负数小数点后小于以及等于5都舍去，大于5的则进位）</li>
<li>ceil: 不小于它的最小整数<blockquote>
<p><strong>floorMod</strong> 和 <strong>floorDiv</strong> 旨在解决整型余数问题。在java中，如果n为负数，n%2为-1，而floorMod(position + adjustment, 12)总是返回一个0到11之间的数字。（对于负的除数，还是会返回负值）。floorDiv则返回0到12之间的数字。</p>
</blockquote>
<h5 id="3-2-自增自减运算"><a href="#3-2-自增自减运算" class="headerlink" title="3.2 自增自减运算"></a>3.2 自增自减运算</h5></li>
<li>前缀：先运算再使用数值</li>
<li>后缀：先使用数值再运算<h5 id="3-3-位运算符"><a href="#3-3-位运算符" class="headerlink" title="3.3 位运算符"></a>3.3 位运算符</h5>&amp;：and 与<br>|：or  或<br>^：xor 异或<br>~：not 非<br>&gt;&gt; 或 &lt;&lt;：位模式左移或右移<br>&gt;&gt;&gt;:用0填充高位  <h5 id="3-4-运算符级别"><a href="#3-4-运算符级别" class="headerlink" title="3.4 运算符级别"></a>3.4 运算符级别</h5><table>
<thead>
<tr>
<th>运算符</th>
<th>结合性</th>
</tr>
</thead>
<tbody><tr>
<td>[].()(方法调用)</td>
<td>从左向右</td>
</tr>
<tr>
<td>! ~ ++ – + -(一元运算) ()(强制类型转换) new</td>
<td>从右向左</td>
</tr>
<tr>
<td>* / %</td>
<td>从左向右</td>
</tr>
<tr>
<td>+ -</td>
<td>从左向右</td>
</tr>
<tr>
<td>&lt;&lt;&gt;&gt; &gt;&gt;&gt;</td>
<td>从左向右</td>
</tr>
<tr>
<td>&lt; &lt;= &gt; &gt;= instanceof</td>
<td>从左向右</td>
</tr>
<tr>
<td>== ！=</td>
<td>从左向右</td>
</tr>
<tr>
<td>&amp;</td>
<td>从左向右</td>
</tr>
<tr>
<td>^</td>
<td>从左向右</td>
</tr>
<tr>
<td>&#124;</td>
<td>从左向右</td>
</tr>
<tr>
<td>&amp;&amp;</td>
<td>从左向右</td>
</tr>
<tr>
<td>&#124;&#124;</td>
<td>从左向右</td>
</tr>
<tr>
<td>? :</td>
<td>从右向左</td>
</tr>
<tr>
<td>= += -= *= /= %= &#124;= ^= &lt;&lt;= &gt;&gt;= &gt;&gt;&gt;=</td>
<td>从右向左</td>
</tr>
<tr>
<td>#### <font color="red">4. 字符串</font></td>
<td></td>
</tr>
<tr>
<td><div id="string"></div></td>
<td></td>
</tr>
</tbody></table>
</li>
</ul>
<h5 id="4-1-字符串"><a href="#4-1-字符串" class="headerlink" title="4.1 字符串"></a>4.1 字符串</h5><blockquote>
<p>Java没有内置的字符串类型，而是在标准Java类库中提供了预定义类：String,且String为final不可变，因此总是线程安全的，一般都用它作为参数传递 </p>
</blockquote>
<ul>
<li><strong>substring(a, b)</strong>：截取字符串  </li>
<li><strong>+</strong> ：连接字符串 (<strong>每次连接，都会构建一个新的String对象</strong>，效率低占空间，使用<strong>StringBuilder</strong>类，通过<strong>apped</strong>添加字符串可避免此问题)</li>
<li><strong>join(“/“, “a”, “b”, “c”)</strong>:分隔字符串 “a/b/c”</li>
<li><strong>equal</strong>:检测两个字符串是否相等<br>“==”运算符只能检测两个字符串是否放在同一位置 </li>
<li><strong>equalIgnoreCase</strong>:忽略大小写检测是否相等  </li>
<li><strong>compareTo(String str)</strong>：按照字典顺序检测一个字符串是否在str前后位置，之前为负，之后为正，相等为0</li>
<li><strong>replace(oldStr, newStr)</strong>：用newStr代替原始字符串中 所有的oldStr，并返回一个新字符串</li>
<li><strong>toLowerCase() / toUpperCase()</strong>：更改大小写，并返回一个新串</li>
<li><strong>trim()</strong>：删除原始字符串头部和尾部的空格</li>
</ul>
<blockquote>
<p><strong>String</strong>类没有提供用于修改字符串的方法，如果想修改，可先substring截取需要的字符，再拼接替换的字符串<br>不可变字符串的优点：编译器可以让字符串共享(复制原始字符串的效率远高于截取拼接，用<strong>StringBuilder</strong>可以高效拼接字符串)  </p>
</blockquote>
<blockquote>
<p><strong>StringBuilder类中常用方法：</strong><br><strong>StringBuilder append(String str)</strong>:追加一个字符串并返回this<br><strong>void setCharAt(int i, char c)</strong>：将第i个位置设为c<br><strong>StringBuilder insert(int offset, String str)</strong>：在offset位置插入一个字符串并返回this<br><strong>StringBuilder delete(int startIndex, int endIndex)</strong>：删除偏移量从startIndex到-endIndex-1的字符并返回this<br><strong>toString()</strong>：返回一个与构建器或缓冲器内容相同的字符串</p>
</blockquote>
<h5 id="4-2-空串-和-null"><a href="#4-2-空串-和-null" class="headerlink" title="4.2 空串 和 null"></a>4.2 空串 和 null</h5><ul>
<li>空串””：是长度为0的字符串。可用str.length()==0 或 str.equals(“”)检测</li>
<li>null：表示目前没有任何对象与该变量关联<blockquote>
<p>检查一个字符串既不是<strong>null</strong>也不是<strong>空串</strong>：<br>if(str != null &amp;&amp; str.length() != 0)</p>
</blockquote>
<h5 id="4-3-String-StringBuilder-StringBuffer-的区别"><a href="#4-3-String-StringBuilder-StringBuffer-的区别" class="headerlink" title="4.3 String / StringBuilder / StringBuffer 的区别"></a>4.3 <font color="red">String / StringBuilder / StringBuffer 的区别</font></h5>执行速度快慢为：<strong>StringBuilder</strong> &gt; <strong>StringBuffer</strong> &gt; <strong>String</strong> ：</li>
</ul>
<blockquote>
<p>因为<strong>String</strong>为字符串常量，而<strong>StringBuilder</strong>和<strong>StringBuffer</strong>均为字符串变量，即String对象一旦创建之后该对象是不可更改的，但另外两者的对象是变量，是可以更改的。  </p>
</blockquote>
<p>在线程安全上，StringBuilder是线程不安全的，而StringBuffer是线程安全的，String为final不可变总是安全的：</p>
<blockquote>
<p>如果一个StringBuffer对象在字符串缓冲区被多个线程使用时，StringBuffer中很多方法可以带有synchronized关键字，所以可以保证线程是安全的，但StringBuilder的方法则没有该关键字，所以不能保证线程安全，有可能会出现一些错误的操作。所以如果要进行的操作是多线程的，那么就要使用StringBuffer，但是在单线程的情况下，还是建议使用速度比较快的StringBuilder。  </p>
</blockquote>
<p><strong>String</strong>：适用于少量的字符串操作的情况<br><strong>StringBuilder</strong>：适用于单线程下在字符缓冲区进行大量操作的情况<br><strong>StringBuffer</strong>：适用多线程下在字符缓冲区进行大量操作的情况  </p>
<h5 id="4-4-输入输出"><a href="#4-4-输入输出" class="headerlink" title="4.4 输入输出"></a>4.4 输入输出</h5><ul>
<li><p>Java SE 6 引入了Console类实现读取密码：</p>
<pre><code>Console cons = new Console();
String username = cons.realLine(&quot;username: &quot;); 
char[] passwd = cons.readPassword(&quot;Password: &quot;);    //显示Password： 并读取输入</code></pre></li>
</ul>
<blockquote>
<p>安全起见，返回的密码存放在一维字符数组中，而不是字符串中 (<strong>在对密码进行处理后，应该马上用一个填充值覆盖数组元素</strong>)</p>
</blockquote>
<h5 id="4-5-格式化输入"><a href="#4-5-格式化输入" class="headerlink" title="4.5 格式化输入"></a>4.5 格式化输入</h5><ul>
<li>Java SE 5.0 引用了C库中的printf方法：  </li>
</ul>
<p><strong>用于printf的转换符</strong>  </p>
<table>
<thead>
<tr>
<th align="center">转换符</th>
<th align="center">类型</th>
<th align="left">举例</th>
</tr>
</thead>
<tbody><tr>
<td align="center">d</td>
<td align="center">十进制整数</td>
<td align="left">77</td>
</tr>
<tr>
<td align="center">x</td>
<td align="center">十六进制整数</td>
<td align="left">9f</td>
</tr>
<tr>
<td align="center">o</td>
<td align="center">八进制整数</td>
<td align="left">237</td>
</tr>
<tr>
<td align="center">f</td>
<td align="center">定点浮点数</td>
<td align="left">15.7</td>
</tr>
<tr>
<td align="center">e</td>
<td align="center">指数浮点数</td>
<td align="left">1.57e+01</td>
</tr>
<tr>
<td align="center">g</td>
<td align="center">通用浮点数</td>
<td align="left">——</td>
</tr>
<tr>
<td align="center">a</td>
<td align="center">十六进制浮点数</td>
<td align="left">0x1.fccdp3</td>
</tr>
<tr>
<td align="center">s</td>
<td align="center">字符串</td>
<td align="left">Hello</td>
</tr>
<tr>
<td align="center">c</td>
<td align="center">字符</td>
<td align="left">H</td>
</tr>
<tr>
<td align="center">b</td>
<td align="center">布尔</td>
<td align="left">True</td>
</tr>
<tr>
<td align="center">h</td>
<td align="center">散列码</td>
<td align="left">42628b2</td>
</tr>
<tr>
<td align="center">tx or Tx</td>
<td align="center">日期时间</td>
<td align="left">已过时，现用java.time类</td>
</tr>
<tr>
<td align="center">%</td>
<td align="center">百分号</td>
<td align="left">%</td>
</tr>
<tr>
<td align="center">n</td>
<td align="center">与平台有关的行分隔符</td>
<td align="left">——</td>
</tr>
</tbody></table>
<p>**用于printf的标志  </p>
<table>
<thead>
<tr>
<th align="left">标志</th>
<th align="left">目的</th>
<th align="left">举例</th>
</tr>
</thead>
<tbody><tr>
<td align="left">+</td>
<td align="left">打印正数负数的符号</td>
<td align="left">+333.33</td>
</tr>
<tr>
<td align="left">空格</td>
<td align="left">在正数之前添加空格</td>
<td align="left">&#124; 333.33&#124;</td>
</tr>
<tr>
<td align="left">0</td>
<td align="left">数字前面补0</td>
<td align="left">00333.33</td>
</tr>
<tr>
<td align="left">-</td>
<td align="left">左对齐</td>
<td align="left">&#124;333.33 &#124;</td>
</tr>
<tr>
<td align="left">(</td>
<td align="left">将负数括在括号内</td>
<td align="left">(333.33)</td>
</tr>
<tr>
<td align="left">,</td>
<td align="left">添加分组分隔符</td>
<td align="left">3,333,33</td>
</tr>
<tr>
<td align="left">#(对于f格式)</td>
<td align="left">包含小数点</td>
<td align="left">3,333.</td>
</tr>
<tr>
<td align="left">#(对于x或0格式)</td>
<td align="left">添加前缀0x或0</td>
<td align="left">0xcafe</td>
</tr>
<tr>
<td align="left">$</td>
<td align="left">给定被格式化的参数索引:%1$x将以十六进制打印第一个参数</td>
<td align="left">159 9F</td>
</tr>
<tr>
<td align="left">&lt;</td>
<td align="left">格式化前面说明的数值:%d%&lt;x 以十进制和十六进制打印同一个数值</td>
<td align="left">159 9F</td>
</tr>
<tr>
<td align="left">- <strong>可以使用静态的String.format方法创建一个格式化的字符串，而不打印输出</strong></td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">##### 4.6 文件输入与输出</td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">- <strong>读取文件</strong>：用File对象构造一个Scanner对象:</td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><figure class="highlight plain"><figcaption><span>in </span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- **写入文件**：构造一个PrintWriter对象(如果文件不存在，创建该文件)：  </span><br><span class="line">```PrintWriter out = new PrintWriter(&quot;myfile.txt&quot;, &quot;UTF-8&quot;);</span><br></pre></td></tr></table></figure></td>
<td align="left"></td>
<td align="left"></td>
</tr>
</tbody></table>
<blockquote>
<p><strong>PrintWriter(String fileName)</strong>:构造一个将数据写入文件的PrintWriter<br><strong>static Path get(String pathName)</strong>:根据给定的路径名构造一个Path</p>
</blockquote>
<h4 id="5-控制流程"><a href="#5-控制流程" class="headerlink" title="5. 控制流程 "></a><font color="red">5. 控制流程 </font></h4><h5 id="5-1-控制流程语句"><a href="#5-1-控制流程语句" class="headerlink" title="5.1 控制流程语句"></a>5.1 控制流程语句</h5><ul>
<li><p>Switch中，case标签可以是：类型为<strong>char、byte、short、int</strong>的常量表达式，<strong>枚举常量</strong>，<strong>字符串字面量</strong>(Java SE 7)  </p>
</li>
<li><p>带标签的break：标签必须放在要跳出的最外层循环之前，且紧跟一个冒号”：”.  </p>
<h5 id="5-2-大数值BigInteger-BigDecimal"><a href="#5-2-大数值BigInteger-BigDecimal" class="headerlink" title="5.2 大数值BigInteger / BigDecimal "></a>5.2 <font color="red">大数值BigInteger / BigDecimal </font></h5></li>
<li><p>java.math包中的两个类，可以处理包含任意长度数字序列的数值</p>
</li>
<li><p>使用<strong>BigInteger.valueOf</strong>方法可以将普通的数值转换为大数值:BigInteger a = new BigInteger.valueOf(100);</p>
</li>
<li><p>不能使用+/<em>等处理大数值，而是使用 *</em>add / multiply** 方法。</p>
<blockquote>
<p><strong>BigInteger add(BigInteger other</strong><br><strong>BigInteger subtract(BigInteger other</strong><br><strong>BigInteger multiply(BigInteger other)</strong><br><strong>BIgInteger divide(BigInteger other)</strong><br><strong>BigInteger mod(BigInteger other)</strong>  返回两个大整数的和、差、积、商、余数。<br><strong>int compareTo(BigInteger other)</strong> 两个大整数相等，返回0；小于返回负数，大于返回正数<br><strong>static BigInteger valueOf(long x)</strong> 返回值等于x的大整数<br><strong>static BigDecimal valueOf(long x, int scale)</strong> 返回值为x或 x / 10 ^ scale的一个大实数  </p>
</blockquote>
<h5 id="5-3-数组-foreach循环"><a href="#5-3-数组-foreach循环" class="headerlink" title="5.3 数组 foreach循环"></a>5.3 数组 foreach循环</h5></li>
<li><p>遍历数组中的每个元素</p>
</li>
<li><p><strong>Arrays.toString(str)</strong>：打印一维数组中的所有值(更简单的遍历打印方法)</p>
</li>
<li><p><strong>Arrays.deepToString(str)</strong>：打印二维数组中的数据元素  </p>
<blockquote>
<p>匿名数组：<strong>new int[] {}</strong>  可以在不创建新变量的情况下重新初始化一个数组<br>在返回值为数组的方法中，如果结果为0，则可以创建一个长度0的数组：new arrName[0]。数组长度为0与null不同。  </p>
</blockquote>
</li>
<li><p><strong>Arrays.copyOf(str, str.length)</strong> ：将一个数组的所有值拷贝到一个新的数组中去，第二个参数是数组长度，<strong>通常用来增加数组的大小</strong>  </p>
<h5 id="5-4-命令行参数"><a href="#5-4-命令行参数" class="headerlink" title="5.4 命令行参数"></a>5.4 命令行参数</h5><blockquote>
<p>public static void main(String[] args){}<br>以java className -g cruel world 的形式运行程序：args数组将包含：<br>args[0]： “-g”<br>args[1]： “cruel”<br>args[2]：”world”  </p>
</blockquote>
<h4 id="数组排序"><a href="#数组排序" class="headerlink" title="***数组排序 "></a><font color="red"><strong>***</strong>数组排序 </font></h4><blockquote>
<p>随机<strong>不重复</strong>抽取一个范围内的数值：<br>将数组最后一个值赋给之前抽取的数的索引，并将总数减去 1 ,则抽取不会重复</p>
</blockquote>
</li>
<li><p><strong>static int binarySearch(type[] a, int start, int end, type v)</strong>：采用二分搜索发查找值  </p>
</li>
<li><p><strong>static void fill(type[] a, type v)</strong>：将数组的所有数据元素设置为v  </p>
</li>
<li><p><strong>static boolean equals(type[] a, type[] b)</strong>：如果两个数组大小相同，且下标相同的元素都对应相等，返回true    </p>
</li>
</ul>
<hr>
<ul>
<li><a href="#back">返回目录</a></li>
</ul>
<h2 id="2-对象与类"><a href="#2-对象与类" class="headerlink" title="2.对象与类"></a><font color="red">2.对象与类</font></h2><p><strong>三个主要特性</strong>：</p>
<ul>
<li>对象的<strong>行为</strong>(<strong>behavior</strong>)：可以对对象施加哪些操作或方法</li>
<li>对象的<strong>状态</strong>(<strong>state</strong>)：施加方法时，对象如何响应</li>
<li>对象<strong>标识</strong>(<strong>identity</strong>)：如何辨别具有相同行为与状态的不同对象</li>
</ul>
<blockquote>
<p>一个<strong>对象变量</strong>并没有实际包含一个对象，而仅仅<strong>引用一个对象</strong><br>任何对象变量的<strong>值</strong>都是对<strong>存储在另外一个地方</strong>的一个对象的<strong>引用</strong>，new操作符的返回值也是一个<strong>引用</strong></p>
</blockquote>
<h4 id="1-类"><a href="#1-类" class="headerlink" title="1. 类"></a>1.<font color="red"> 类</font></h4><p><strong>类之间的关系</strong>：  </p>
<ul>
<li><strong>依赖(“uses-a”)</strong>：一个类的方法操作另一个类的对象  </li>
<li><strong>聚合(“has-a”)</strong>：类A 的对象包含 类B 的对象  </li>
<li><strong>继承(“is-a”)</strong>：类A 扩展 类B，继承 类B的方法<h5 id="1-1-更改器方法-与-访问器方法"><a href="#1-1-更改器方法-与-访问器方法" class="headerlink" title="1.1 更改器方法 与 访问器方法"></a>1.1 更改器方法 与 访问器方法</h5></li>
<li>更改器方法：调用后可以改变对象的状态 ，setter</li>
<li>访问器方法：只访问对象而不修改对象 ，getter</li>
</ul>
<h5 id="1-2-构造器"><a href="#1-2-构造器" class="headerlink" title="1.2 构造器"></a>1.2 <font color="red">构造器</font></h5><ul>
<li><p>构造器总是伴随着new操作符的执行被调用，而不能对一个已经存在的对象调用构造器来达到重新设置实力域的目的</p>
</li>
<li><p>构造器与类同名</p>
</li>
<li><p>每个类可以有一个以上的构造器</p>
</li>
<li><p>构造器可以有0个、1个或多个参数</p>
</li>
<li><p>构造器没有返回值</p>
</li>
<li><p>所有Java的对象都是在堆中构造的</p>
</li>
<li><p>不要在构造器中定义与实例域重名的局部变量</p>
<h5 id="1-3-隐式参数和显式参数"><a href="#1-3-隐式参数和显式参数" class="headerlink" title="1.3 隐式参数和显式参数"></a>1.3 隐式参数和显式参数</h5><p>  public void raiseSalary(double byPercent){<br>  double raise = salary * byPercent / 100;     //可以这样调用 double raise = this.salary * byPercent / 100;<br>   salary += raise;                            //this,salary += raise;<br>  } </p>
</li>
<li><p>raiseSalary方法有两个参数，第一个为隐式参数，是在方法名之前的类对象，第二个为显式参数，位于方法名后面括号中。</p>
</li>
<li><p>隐式参数：方法调用的目标或接收者，<strong>this</strong>关键字表示隐式参数</p>
</li>
<li><p>显式参数：明显地列在方法声明中</p>
<h5 id="1-4-封装的优点"><a href="#1-4-封装的优点" class="headerlink" title="1.4 封装的优点"></a>1.4 封装的优点</h5></li>
<li><p>通过 getName()、getAge()形式的方法获取实力域值，称为访问器方法 或 域访问器。</p>
</li>
<li><p>name是一个只读域，在构造器中设置完毕，就没有任何方法可以对它进行修改，这样确保name域不会受到外界的破坏</p>
<blockquote>
<p>在需要获得或设置实力域的值时,应提供：<br><strong>一个私有的数据域</strong><br><strong>一个公有的域访问器方法</strong><br><strong>一个公有的域更改器方法</strong> </p>
</blockquote>
</li>
<li><p>优点<strong>：可以改变内部实现，除了该类的方法之外，不会影响其他代码；更改器方法可以执行错误检查</strong>  </p>
</li>
<li><p><strong>注意</strong>：不要编写返回引用可变对象的访问器方法，否则会破坏封装性。  </p>
</li>
<li><p>如果需要返回一个可变数据域的拷贝，就应该使用clone。</p>
<h5 id="1-5-私有方法"><a href="#1-5-私有方法" class="headerlink" title="1.5 私有方法"></a>1.5 私有方法</h5><blockquote>
<p>在实现一个类时，所有数据域都应该设置为私有的，大部分方法都设计为公有的。公有方法不能随意删除，其他代码可能依赖于它。<br>如果希望将一个计算代码划分成若干个独立的辅助方法，或者需要一个特别的协议以及一个特别的调用次序，可以将方法设为private的。(P111) </p>
</blockquote>
<h5 id="1-6-final实力域"><a href="#1-6-final实力域" class="headerlink" title="1.6 final实力域"></a>1.6 final实力域</h5><ul>
<li>可以将实力域定义为final，构建对象时必须初始化这样的域，且不可更改；   </li>
<li>final大都应用于基本类型域，或不可变类的域(类中每个方法都不会改变其对象,如String类)  <h5 id="1-7-静态域与静态方法"><a href="#1-7-静态域与静态方法" class="headerlink" title="1.7 静态域与静态方法"></a>1.7 静态域与静态方法</h5></li>
</ul>
</li>
<li><p>静态域：如果域定义为static，则一个类中只有一个这样的域；</p>
</li>
<li><p>静态方法：一种不能向对象实施操作的方法，或没有this的方法(在非静态方法中，this表示这个方法的隐式参数)  </p>
</li>
<li><p>使用静态方法：一个方法不需要访问对象状态,其所需参数都是通过显式参数提供(如:Math.pow)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一个方法只需要访问类的静态域。</p>
<h5 id="1-8-工厂方法"><a href="#1-8-工厂方法" class="headerlink" title="1.8 工厂方法"></a>1.8 工厂方法</h5><p>静态方法还有另一常见用途，使用静态工厂方法来构造对象。<br>如：NumberFormat类  </p>
<p>  NumberFormat currencyFormatter = NumberFormat.getCurrencyInstance();<br>  NumberFormat percentFormat = NumberFormat.getPercentInstance();<br>  double x = 0.1;<br>  syso.print(currencyFormatter.format(x))            //prints $0.10<br>  syso.print(percentFormatter.fotmat(x));            //prints 10%</p>
<blockquote>
<p>不使用构造器完成以上操作的原因：无法命名构造器，构造器的名字必须与类名相同，这里希望将得到的货币实力和百分比实例采用不同的名字。<br>当使用构造器时，无法改变所构造的对象类型。而工厂方法将返回一个DecimalFormat类对象。</p>
</blockquote>
<h5 id="1-9-main方法"><a href="#1-9-main方法" class="headerlink" title="1.9 main方法"></a>1.9 main方法</h5></li>
<li><p>main方法不对任何对象进行操作，在启动程序时还没有任何一个对象，静态的main方法将执行并创建程序所需要的对象。  </p>
<h5 id="1-10-方法参数"><a href="#1-10-方法参数" class="headerlink" title="1.10 方法参数"></a>1.10 方法参数</h5></li>
<li><p>按值调用：表示方法接收的是调用者提供的值。(Java采用按值调用，方法得到的是所有参数值的一个拷贝)</p>
</li>
<li><p>按引用调用：表示方法接收的是调用者提供的变量地址。  </p>
</li>
<li><p><font color="red"><strong>方法得到的是对象引用的拷贝，对象引用及其他的拷贝同时引用同一个对象(对象引用是按值传递的)</strong></font>  </p>
<blockquote>
<p><strong>Java中方法参数的使用情况：</strong><br>1.一个方法不能修改一个基本数据类型的参数(即数值型或布尔型) </p>
</blockquote>
<pre><code>private int s = 0;
public void changeParameter(int a) {a++;}
public static void main(String[] args) {
    t.changeParameter(t.s);
    System.out.println(t.s);
}</code></pre><blockquote>
<p>2.一个方法可以改变一个对象参数的状态<br>3.一个方法不能让对象参数引用一个新的对象  </p>
</blockquote>
<hr>
<h4 id="2-对象构造"><a href="#2-对象构造" class="headerlink" title="2.对象构造"></a><font color="red">2.对象构造</font></h4><h5 id="2-1-重载"><a href="#2-1-重载" class="headerlink" title="2.1 重载"></a>2.1 重载</h5></li>
<li><p><strong>重载：</strong> 发生在同一个类中，方法名必须相同，参数类型不同、个数不同、顺序不同，方法返回值和访问修饰符可以不同，发生在编译时。 　　</p>
</li>
<li><p><strong>重写：</strong>   发生在父子类中，方法签名(方法名字和参数列表)必须相同，返回值范围小于等于父类，抛出的异常范围小于等于父类，访问修饰符范围大于等于父类；如果父类方法访问修饰符为 private 则子类就不能重写该方法。</p>
<h5 id="2-2-默认域初始化"><a href="#2-2-默认域初始化" class="headerlink" title="2.2 默认域初始化"></a>2.2 默认域初始化</h5></li>
<li><p>在构造器中没有显式地给域赋予初值，就会被自动地赋为默认值(数值为0，boolean为false，对象引用为null)，而<strong>方法中的局部变量必须明确地初始化。</strong></p>
<h5 id="2-3-参数名"><a href="#2-3-参数名" class="headerlink" title="2.3 参数名"></a>2.3 参数名</h5><blockquote>
<p>一般在参数前面加个“a”， 或者 参数变量用相同的名字将实例域屏蔽，但可以采用 this隐式参数 来访问实例域</p>
</blockquote>
<h5 id="2-4-初始化块"><a href="#2-4-初始化块" class="headerlink" title="2.4 初始化块"></a>2.4 初始化块</h5></li>
<li><p>初始化数据域的方法：在构造器中设置值， 或 在声明中赋值  </p>
</li>
<li><p>或 初始化块：数据域在对象初始化块中被初始化，先运行初始化块，再运行构造器的主体.(通常直接将初始化块代码放入构造器)  </p>
<pre><code>``` {
     id = nextId;
     nextId++;
    ``` }</code></pre></li>
<li><p>使用静态初始化块对静态域进行初始化  </p>
<pre><code class="static{">    ...
}</code></pre>
<p>在类第一次加载时，将会初始化静态域  </p>
<h5 id="2-5-finalize方法"><a href="#2-5-finalize方法" class="headerlink" title="2.5 finalize方法"></a>2.5 finalize方法</h5></li>
<li><p><strong>在垃圾回收器清除之前调用</strong>，回收资源，<strong>不要用来回收任何短缺资源，因为很难知道什么时候才能够调用</strong>。  </p>
</li>
<li><p>确保finalizer方法在Java关闭前调用：使用Runtime.addShutdownHook添加“关闭钩”。</p>
</li>
<li><p>某个资源在使用完毕后要立刻关闭，可以使用close()方法  </p>
<h5 id="2-6-包"><a href="#2-6-包" class="headerlink" title="2.6 包"></a>2.6 包</h5></li>
<li><p>在两个包中有相同名称的类时，不能使用 * 来导入，可以在类名前面加上完整包名。  </p>
</li>
<li><p>编译器在编译源文件时不检查目录结构  </p>
<h4 id="3。-注释"><a href="#3。-注释" class="headerlink" title="3。 注释"></a>3。 注释</h4></li>
<li><p>@param：变量描述</p>
</li>
<li><p>@return：描述</p>
</li>
<li><p>@throws：类描述  </p>
</li>
<li><p>@author：姓名  </p>
</li>
<li><p>@version：版本  </p>
</li>
<li><p>@since：文本  </p>
</li>
<li><p>@deprecated：文本，添加一个不再使用的注释  </p>
</li>
<li><p>@see：引用，超链接  </p>
</li>
</ul>
<h2 id="类的设计技巧"><a href="#类的设计技巧" class="headerlink" title="类的设计技巧"></a><font color="red">类的设计技巧</font></h2><p><strong>1.保证数据私有</strong><br><strong>2.对数据初始化</strong><br><strong>3.不要在类中使用过多的基本类型</strong><br><strong>4.不是所有的域都需要独立的域访问器和更改器</strong><br><strong>5.将职责过多的类进行分解</strong><br><strong>6.类名和方法名应体现它们的职责</strong><br><strong>7.优先使用不可变的类</strong>    </p>
<h2 id="3-继承"><a href="#3-继承" class="headerlink" title="3.继承"></a><font color="red">3.继承</font></h2><ul>
<li><strong>一个对象变量可以指示多种实际类型的现象被称为 多态</strong>  </li>
<li><strong>在运行时能够自动地选择调用哪个方法的现象称为 动态绑定</strong>(默认的处理方式)   </li>
<li><strong>不允许扩展的类称为final类，不可被继承</strong>  </li>
<li>强制转换：应先用if(Obj instanceof Obj)判断是否能够成功转换  </li>
<li>只能在继承层次内进行类型转换   </li>
</ul>
<p><font color="red"><strong>动态绑定的重要特性：无需对现存代码进行修改，就可以对程序进行扩展。</strong></font><br><strong>理解方法调用：</strong></p>
<blockquote>
<p>1.编译器查看对象的声明类型和方法名。<br>2.编译器查看调用方法时提供的参数类型。如果在所有名为上述的方法中存在一个与提供的参数类型完全匹配，就选择这个方法。此过程称为<strong>重载解析</strong>。<br>3.如果是private、static、final方法或构造器，编译器将可以准确地知道应该调用哪个方法。这种调用方式为<strong>静态绑定</strong>。<br>4.当程序运行，并且采用动态绑定调用方法时，虚拟机一定调用与x所引对象的实际类型最合适的那个类的方法。  </p>
</blockquote>
<p><strong>调用e.getSalary()方法的解析过程</strong>：  </p>
<blockquote>
<p>1.虚拟机提取e的实际类型的放发表。既可能时Employee、Manager方法表，也可能时Employee类的其他子类的方法表。<br>2.虚拟机搜索定义getSalary签名的类。此时虚拟机已经知道应该调用哪个方法。<br>3.虚拟机调用方法。</p>
</blockquote>
<div id="abstract">
#### 1.抽象类 abstract  
1.包含一个或多个抽象方法的类必须为抽象的，但抽象类可以不包含抽象方法  
2.抽象类可以包含具体的数据和方法，但不能被实例化     
3.抽象类充当占位角色，具体实现 在子类中  
4.扩展抽象类的两种方法：在抽象类中定义部分抽象方法或不定义抽象方法，则子类必须为抽象类；定义全部的抽象方法，则子类就不是抽象的  
5.可以定义一个抽象类的对象变量，但只能引用非抽象子类的对象：Person p = new Student();  
#### <font color="red">2. == 和 equals</font>  
**==** : 它的作用是判断两个对象的地址是不是相等。即，判断两个对象是不是同一个对象。(基本数据类型==比较的是值，引用数据类型==比较的是内存地址)

<p><strong>equals()</strong> : 它的作用也是判断两个对象是否相等。但它一般有两种使用情况：</p>
<ul>
<li>情况1：类没有覆盖 equals() 方法。则通过 equals() 比较该类的两个对象时，等价于通过“==”比较这两个对象。</li>
<li>情况2：类覆盖了 equals() 方法。一般，我们都覆盖 equals() 方法来两个对象的内容相等；若它们的内容相等，则返回 true (即，认为这两个对象相等)。</li>
</ul>
<p><strong>举个例子：</strong></p>
<pre><code>java
public class test1 {
public static void main(String[] args) {
String a = new String(&quot;ab&quot;); // a 为一个引用
String b = new String(&quot;ab&quot;); // b为另一个引用,对象的内容一样
String aa = &quot;ab&quot;; // 放在常量池中
String bb = &quot;ab&quot;; // 从常量池中查找
if (aa == bb) // true
System.out.println(&quot;aa==bb&quot;);
if (a == b) // false，非同一对象
System.out.println(&quot;a==b&quot;);
if (a.equals(b)) // true
System.out.println(&quot;aEQb&quot;);
if (42 == 42.0) { // true
System.out.println(&quot;true&quot;); }}}</code></pre><p><strong>说明：</strong></p>
<ul>
<li><p>String 中的 equals 方法是被重写过的，因为 object 的 equals 方法是比较的对象的内存地址，而 String 的 equals 方法比较的是对象的值。</p>
</li>
<li><p>当创建 String 类型的对象时，虚拟机会在常量池中查找有没有已经存在的值和要创建的值相同的对象，如果有就把它赋给当前引用。如果没有就在常量池中重新创建一个 String 对象。  </p>
<h4 id="3-hashCode"><a href="#3-hashCode" class="headerlink" title="3. hashCode"></a>3. hashCode</h4></li>
<li><p><strong>散列码</strong>是由对象导出的一个整型值，是没有规律的  </p>
</li>
<li><p><strong>hashCode方法定义在Object类中，因此每个对象都有一个默认的散列码，值为对象的存储地址。</strong>  </p>
</li>
<li><p>StringBuilder类中没有定义hashCode方法，它的散列码是由Object类的默认hashCode方法导出的对象存储地址<br>String类计算hashCode： </p>
<pre><code>int hash = 0;
for(int i=0; i&lt;length(); i++){
hash = 31 * hash + charAt(i);
    }</code></pre></li>
<li><p>字符串内容相同，则 散列码相同    </p>
<blockquote>
<ul>
<li><strong>int hashCode()</strong> ：返回对象的散列码   </li>
</ul>
</blockquote>
</li>
<li><p><strong>static int hash(Object…Objects)</strong>  ：返回一个散列码，由提供的所有对象的散列码组合得到    </p>
</li>
<li><p><strong>static int hashCode((int|long|double|char|boolean…) value)</strong>  ： 返回给定值的散列码    </p>
</li>
<li><p><strong>static int hashCode(type[] a)</strong>  ： 计算数组a的散列码   </p>
<h4 id="4-toString"><a href="#4-toString" class="headerlink" title="4. toString"></a>4. toString</h4></li>
<li><p>只要对象与一个字符串通过操作符“+”连接，Java编译就会自动地调用toString方法，以便获得这个对象的字符串描述。  </p>
</li>
<li><p>强烈建议为自定义的每个类添加toString方法，便于从日志记录中获取信息和调试。  </p>
</li>
<li><p>如下定义 </p>
<pre><code>public String toString(){
return getClass().getName()+&quot;[name=&quot; + name + &quot;,age=&quot; + age + &quot;]&quot;;   
}</code></pre><h4 id="5-泛型数组列表ArrayList-lt-gt"><a href="#5-泛型数组列表ArrayList-lt-gt" class="headerlink" title="5. 泛型数组列表ArrayList&lt;&gt;()"></a>5. 泛型数组列表ArrayList&lt;&gt;()</h4></li>
<li><p>void ensureCapacity(int capacity)：确定数组存储元素数量后，分配包含capacity个内部数组  </p>
</li>
<li><p>int size()：返回数组列表中包含的实际元素数目  </p>
</li>
<li><p>void TrimToSize()：将数组列表的存储容量削减到当前尺寸(垃圾回收器回收多余的存储空间)     </p>
<blockquote>
<p>使用get、set实现访问或改变数组元素的操作<br>set方法只能替换数组中已经存在的元素内容</p>
</blockquote>
</li>
</ul>
<p>灵活扩展数组并方便访问数组元素：</p>
<pre><code>ArrayList&lt;X&gt; list = new ArrayList&lt;&gt;();
while(...){
    x = ...;
list.add(x);
}
X[] a = new X[list.size()];  
list.toArray(a);       //在数组列表中间插入元素
int n = staff.size()/2;
staff.add(n, e);</code></pre><h4 id="6-自动装箱与拆箱"><a href="#6-自动装箱与拆箱" class="headerlink" title="6.  自动装箱与拆箱"></a>6.  自动装箱与拆箱</h4><p><strong>装箱</strong>：将基本类型用它们对应的引用类型包装起来；</p>
<p><strong>拆箱</strong>：将包装类型转换为基本数据类型；</p>
<ul>
<li><p>自动装箱规范要求<strong>boolean、byte、char &lt;= 127，介于-128~127之间的short和int</strong>被包装到固定的对象中。</p>
</li>
<li><p>由于包装器类引用可以为null，所有自动装箱有可能抛出NullPointerException异常。</p>
</li>
<li><p>装箱和拆箱是编译器认可的，而不是虚拟机  </p>
</li>
<li><p>包含在包装器中的内容不会改变，可以用org.omg.CORBA包中的holder类型如IntHolder、BooleanHolder等来访问存储在其中的值： </p>
<pre><code>public static void triple(IntHolder x){
    x.value = 3 * x.value;
}</code></pre></li>
<li><p><strong>static int parseInt(String s[, int radix])</strong>： 返回字符串s表示的整形数值(默认十进制)。或者radix规定的进制。</p>
</li>
<li><p><strong>Static Integer valueOf(String s[, int radix])</strong>：返回用s表示的整形数值进行初始化后的一个新Integer对象。或者radix规定的进制。  </p>
</li>
<li><p><strong>Number parse(String s)</strong>：返回数字值，假设给定的String表示了一个数值。</p>
<h4 id="7-可变参数的方法"><a href="#7-可变参数的方法" class="headerlink" title="7.可变参数的方法"></a>7.可变参数的方法</h4></li>
<li><p>max方法可以接收任意数量的参数，<strong>Object…</strong>与<strong>Object[]</strong>一样  </p>
<pre><code>public static double max(double...values){
    double largest = Double.NEGATIVE_INFINITY;
    for(double v:values)
    if(v &gt; largest) largest = v;
    return largest;
}</code></pre><p>main方法可以声明为下列形式：<br>public static void main(String…args)  </p>
</li>
</ul>
<h2 id="继承的设计技巧"><a href="#继承的设计技巧" class="headerlink" title="继承的设计技巧"></a><font color="red">继承的设计技巧</font></h2><p><strong>1.将公共操作和域放在超类；</strong><br><strong>2.不要使用受保护的域；</strong><br><strong>3.使用继承实现”is-a”关系；</strong><br><strong>4.除非所有继承的方法都有意义，否则不要使用继承；</strong><br><strong>5.再覆盖方法时，不要改变预期的行为；</strong><br><strong>6.使用多态，而非类型信息；</strong><br><strong>7.不要过多的使用反射。</strong>  </p>
<hr>
<ul>
<li><a href="#back">返回目录</a></li>
</ul>
<h2 id="4-接口、lambda"><a href="#4-接口、lambda" class="headerlink" title="4. 接口、lambda"></a><font color="red">4. 接口、lambda</font></h2><p><font size="5"><strong>接口</strong></font>      </p>
<ul>
<li>描述类具有什么功能  </li>
<li>接口没有实例  </li>
<li>实现接口的类必须实现接口中的所有方法  </li>
</ul>
<p><font size="5"><strong>lambda</strong></font>    </p>
<ul>
<li>表示可以在将来某个时间点执行的代码块的简洁方法。可以用一种简洁的方式表示使用回调或变量行为的代码。   </li>
</ul>
<p><font size="5"><strong>内部类</strong></font>  </p>
<ul>
<li>主要用于设计具有相互协作关系的类集合</li>
</ul>
<p><font size="5"><strong>代理</strong></font>  </p>
<ul>
<li>一种实现任意接口的对象。非常专业的构造工具，可以用来构建系统级的工具</li>
</ul>
<div id="interface">

<h4 id="1-接口"><a href="#1-接口" class="headerlink" title="1. 接口"></a>1. 接口</h4><ul>
<li>接口中的所有方法自动地属于public；  </li>
<li>Java SE 8 之后，接口中可以提供简单的方法，且方法不能引用实例域；  </li>
<li>提供实例域和方法实现的任务应该由实现接口的那个类来完成；  </li>
<li>在实现接口时，必须把方法声明为public；</li>
<li>接口变量必须引用实现了接口的类对象；  </li>
<li>可以使用instance检查一个对象是否实现了某个特定的接口；  </li>
<li>接口中不能包含实例域或静态方法，却可以包含常量(Java SE 8可以有静态方法)；  </li>
<li>接口中的域会自动被设为public static final  </li>
<li>每个类只能继承一个类，却可以实现多个接口；  </li>
<li>接口也可以被继承扩展(extends)</li>
</ul>
<blockquote>
<p>1.为什么必须用接口规定类：因为Java是强类型语言，在调用方法时，编译器会检查这个方法是否存在，当一个方法中有调用某个方法，则编译器必须确认这个方法一定存在，用接口来规定就表示一定有这个方法。     </p>
</blockquote>
<blockquote>
<p>2.为什么有了抽象类还需要接口： 每个类只能继承一个类，却可以实现多个接口。</p>
</blockquote>
<h5 id="1-1-接口静态方法"><a href="#1-1-接口静态方法" class="headerlink" title="1.1 接口静态方法"></a>1.1 接口静态方法</h5><p>Java SE 8 中允许在接口中增加静态方法，但目前为止，都是将静态方法放在伴随类中。在标准库中有成对出现的接口和实用工具类，Collection/Collections或Path/Paths。（这个技术已经过时，现在可以直接在接口中实现方法。）</p>
<h5 id="1-2-默认方法"><a href="#1-2-默认方法" class="headerlink" title="1.2 默认方法"></a>1.2 默认方法</h5><p>可以为接口提供一个默认实现，必须用 default 修饰。</p>
<pre><code>public interface Comparable&lt;T&gt;{
    default int compareTo(T other) {return 0;}
}                    </code></pre><blockquote>
<p>为什么要默认方法：因为接口中的所有方法都要实现，若只需要其中一两个方法，则可以将方法都声明为default，需要时只需覆盖即可。</p>
</blockquote>
<hr>
<p><strong>解决默认方法冲突</strong>：  </p>
<blockquote>
<p>如果在一个接口中将方法定义为默认方法，又在父类或另一个接口定义了同样的方法，则   <strong>父类优先</strong><br><strong>接口冲突</strong>：父接口提供了一个默认方法，另一接口提供了同样的方法(不论是否是默认参数)，则必须覆盖这个方法来解决冲突。<br>当一个类同时实现两个同样的接口时，需要程序员解决二义性。</p>
</blockquote>
<h3 id="接口与回调-callback"><a href="#接口与回调-callback" class="headerlink" title="接口与回调(callback)"></a><font color="red">接口与回调(callback)</font></h3><p>回调是一种常见的程序设计模式，可以指出某个特定事件发生时应该采取的动作。</p>
<pre><code>public class TimerTest{
    public static void main(String[] args){
        ActionListener listener = new TimePrinter();    //构造TimePrinter类对象并转换为ActionListener
        Timer t = new Timer(10000, listener);            //将ActionListener对象传给Timer类
        t.start();    
        JOptionPane.showMessageDialog(null, &quot;Quit program?&quot;);    //null表示在屏幕中央输出语句
        System.exit(0);
    }
}                      
class TimerPrinter implements ActionListener{
    public void actionPerformed(ActionEvent event){        //实现ActionListener接口中的方法
        System.out.println(&quot;At the tone, the time is &quot; + new Date());
        Toolkit.getDefaultToolkit().beep();                //发出铃响
    }
}</code></pre><hr>
<h3 id="comparator接口-P224"><a href="#comparator接口-P224" class="headerlink" title="comparator接口(P224)"></a>comparator接口(P224)</h3><p>当需要按长度来比较时，可以使用一个数组和一个比较器作为参数，比较器是实现了Comparator接口的实例，  </p>
<pre><code>public interface Comparator&lt;T&gt;{
    int compare(T first, T second);
}</code></pre><p>按长度比较字符串，可以定义如下实现Comparator<string>的类：</string></p>
<pre><code>class LengthComparator implements Comparator&lt;String&gt;{
    public int compare(String first, String second){
        return first.length() - second.length();
    }
}                      </code></pre><p>具体完成比较时，需要建立一个实例：</p>
<pre><code>Comparator&lt;String&gt; comp = new LengthComparator();
if(comp.compare(word[i], word[j])  &gt;  0)...</code></pre><hr>
<h3 id="对象克隆-Cloneable接口"><a href="#对象克隆-Cloneable接口" class="headerlink" title="对象克隆 (Cloneable接口)"></a>对象克隆 (Cloneable接口)</h3><ul>
<li><p>Cloneable接口时Java提供的一组<strong>标记接口</strong>之一。通常用来确保一个类实现一个或一组特定的方法。<strong>标记接口不包含任何方法</strong>。它的唯一作用就是允许在类型查询中使用instanceof：(建议自己的程序中不要使用标记接口)</p>
<pre><code>if(Obj instanceof Cloneable)...</code></pre></li>
<li><p>Cloneable接口提供了一个安全的clone方法 (它没有指定clone方法，只是从Object类继承的)</p>
</li>
<li><p>Clone方法是Object的一个protected方法，因此代码不能直接调用这个方法。它是个<strong>浅拷贝</strong>，当原对象与克隆对象的子对象是<strong>不可变</strong>时，它是安全的。但通常子对象都是可变的，则需要重新定义一个clone方法来建立<strong>深拷贝</strong>，同时克隆所有子对象。 </p>
</li>
</ul>
<p>对于每一个类，需要确定：  </p>
<blockquote>
<p>1，默认的clone方法是否满足要求；<br>2.是否可以在可变的子对象上调用clone来修补默认的clone方法；<br>3.是否不该使用clone。  </p>
</blockquote>
<p>实际上第3个是默认选项。如果选择1、2，类必须：  </p>
<blockquote>
<p>1.实现Cloneable接口；<br>2.重新定义clone方法，并指定public访问修饰符。  </p>
<ul>
<li>对于Object类的protected clone方法，虽然所有类都是Object的子类，但子类只能调用protected clone方法来克隆它自己的对象，必须重新定义clone为public才能允许所有方法克隆对象。</li>
</ul>
</blockquote>
<p><strong>深拷贝</strong><br>建立深拷贝，需要克隆对象中可变的实例域。 </p>
<pre><code>public Employee clone() throws CloneNotSupportedException{
    Employee cloned = (Employee) super.clone();
    cloned.hireDay = (Date) hireDay.clone();        //hireDay是一个Date，可变的
    return cloned;
}</code></pre><p>！！！</p>
<ul>
<li><p><strong>所有数组类型都有一个public的clone方法</strong>，而不是protected。可以用这个方法建立一个新数组，包含原数组所有元素的副本。</p>
</li>
<li><p><a href="#back">返回目录</a></p>
</li>
</ul>
<div id="clone">

<h2 id="渐析java的浅拷贝和深拷贝"><a href="#渐析java的浅拷贝和深拷贝" class="headerlink" title="渐析java的浅拷贝和深拷贝"></a><strong>渐析java的浅拷贝和深拷贝</strong></h2><p>浅拷贝：使用一个已知实例对新创建实例的成员变量逐个赋值，这个方式被称为浅拷贝。</p>
<p>深拷贝：当一个类的拷贝构造方法，不仅要复制对象的所有非引用成员变量值，还要为引用类型的成员变量创建新的实例，并且初始化为形式参数实例值。这个方式称为深拷贝</p>
<p>也就是说浅拷贝只复制一个对象，传递引用，不能复制实例。而深拷贝对对象内部的引用均复制，它是创建一个新的实例，并且复制实例。</p>
<p>对于浅拷贝当对象的成员变量是基本数据类型时，两个对象的成员变量已有存储空间，赋值运算传递值，所以浅拷贝能够复制实例。但是当对象的成员变量是引用数据类型时，就不能实现对象的复制了。 </p>
<p>存在一个对象Person，代码如下：<br>    public class Asian {<br>        private String skin;<br>        Person person;</p>
<pre><code>    public Asian(String skin,Person person){
        this.skin = skin;
        this.person = person;                    //引用赋值
    }

    public Asian(Asian asian){                 //拷贝构造方法，复制对象
        this(asian.skin,asian.person);           
    }
}</code></pre><p> 上面的对象Person有三个成员变量。name、sex、age。两个构造方法。第二个的参数为该对象，它称为拷贝构造方法，它将创建的新对象初始化为形式参数的实例值，通过它可以实现对象复制功能。</p>
<p>  又有一个对象Asian,如下：<br>    public class Asian {<br>        private String skin;<br>        Person person;</p>
<pre><code>    public Asian(String skin,Person person){
        this.skin = skin;
        this.person = person;                    //引用赋值
    }

    public Asian(Asian asian){                 //拷贝构造方法，复制对象
        this(asian.skin,asian.person);           
    }
}</code></pre><p>上面对象也存在着两个成员变量，skin 和Person对象<br>   对于person对象有如下：  </p>
<pre><code>Person p1 = new Person(&quot;李四&quot;,&quot;mam&quot;,23);
Person p2 = new Person(P1);</code></pre><p> 当调用上面的语句时。P2对象将会对P1进行复制。执行情况如下如下图：  </p>
<p><img src="https://i.imgur.com/zYOolzB.jpg" alt></p>
<pre><code>Asian a1 = new Asian(&quot;yellow&quot;,new Person(&quot;李四&quot;,&quot;mam&quot;,23));
Asian a2 = new Asian(a1);</code></pre><p>对于Asian对象有：</p>
<p>New Asian(a1)执行Asian类的拷贝构造方法，由于对象赋值是引用赋值。使得a1和a2引用同一个对象</p>
<p>如下图：</p>
<p><img src="https://i.imgur.com/evpmlPf.jpg" alt></p>
<p>  当a1执行某条可以改变该值的语句时，那么a1将会通过这个语句也可以改变a2对象的成员变量  </p>
<p>  如果执行以下语句：</p>
<p><img src="https://i.imgur.com/9PmF24I.jpg" alt>   </p>
<hr>
<div id="lambda">

<h3 id="2-lambda"><a href="#2-lambda" class="headerlink" title="2. lambda"></a><font color="red">2. lambda</font></h3><ul>
<li><p>lambda是一个可传递的代码块，可以在以后执行一个或多次。  </p>
</li>
<li><p>带参数变量的表达式称为lambda表达式。  </p>
</li>
<li><p>即使lambda表达式没有参数，仍然要提供空括号(),就像无参方法一样;  </p>
</li>
<li><p>如果可以推导出一个lambda表达式的参数，则可以忽略其类型：  </p>
<pre><code>Comparator&lt;String&gt; comp = (first, second) -&gt; first.length() - second.length(); //因为这个lambda将赋给一个字符串比较器  </code></pre></li>
<li><p>如果方法<strong>只有一个参数</strong>，而且这个参数的类型可以推导出，甚至可以省略小括号：</p>
<pre><code>ActionListener listener = event -&gt; System.out.println(&quot;...&quot;);    </code></pre></li>
<li><p>无需指定lambda的返回类型，会由上下文推导得出：</p>
<pre><code>(String first, String second) -&gt; first.length() - second.length()    //可以在需要int类型结果的上下文中使用  </code></pre></li>
<li><p>如果一个lambda表达式只在某些分支返回一个值，而在另外一些分支不返回值，这是不合法的。  </p>
<pre><code>(int x) -&gt; {if(x &gt;= 0) return 1;}  </code></pre><p>修改ActionListener接口：</p>
<pre><code>Timer t = new Timer(10000, event -&gt; System.out.println(&quot;...&quot;));  </code></pre><h2 id="函数式接口"><a href="#函数式接口" class="headerlink" title="函数式接口"></a><font color="red">函数式接口</font></h2></li>
<li><p>对于只有一个抽象方法的接口，需要这个接口的对象时，就可以提供一个lambda表达式。称为函数式接口。 如：Comparator接口</p>
<pre><code>Arrays.sort(words, (first, second) -&gt; first.length() - second.length());    //Arrays.sort的第二个参数需要一个Comparator实例  </code></pre></li>
</ul>
<p>！！！！！！！</p>
<ul>
<li><strong>在Java中，对lambda表达式能做的也只是能转换成函数式接口</strong>  </li>
<li>不能把lambda赋给类型为Object的变量，Object不是一个函数式接口  </li>
</ul>
<div id="methodReference">

<h2 id="方法引用"><a href="#方法引用" class="headerlink" title="方法引用"></a><font color="red">方法引用</font></h2><pre><code>Timer t = new Timer(10000, System.out::println);</code></pre><ul>
<li><p>System.out::println是一个方法引用，等价于lambda表达式  x -&gt; System.out.println(x);  </p>
</li>
<li><p>如果想不考虑大小写来对字符串排序：</p>
<pre><code>Arrays.sort(strings, String::compareToIgnoreCase)</code></pre><p>方法引用有3种情况：  </p>
</li>
</ul>
<ol>
<li><strong>object :: instanceMethod</strong>  </li>
<li><strong>Class :: staticMethod</strong>  </li>
<li><strong>Class :: instanceMethod</strong>  <blockquote>
<p>1和2等价于lambda表达式，类似于<strong>Math::pow</strong>等价于 <strong>(x, y) -&gt; Math.pow(x, y)</strong><br>对于3，第一个参数会成为方法的目标。如：<strong>String::compareTOIgnoreCase</strong>等价于<strong>(x, y) -&gt; x.compareToIgnoreCase(y)</strong></p>
</blockquote>
</li>
</ol>
<p><font color="red">类似于lambda表达式，方法引用不能独立存在，总是会转换为函数式接口的实例。  </font></p>
<ul>
<li>可以在方法引用里使用this。如：this::equals 等同于 x -&gt; this.equals(x)</li>
<li>使用super也是合法的 <strong>super::instanceMethod</strong>  </li>
</ul>
<p>使用this作为目标，会调用给定方法的父类版本：</p>
<pre><code>class Greeter{
    public void greet(){
        System.out.println(&quot;Hello&quot;);
    }
}

class TimedGreeter extends Greeter{
    public void greet(){
        Timer t = new Timer(1000, super::greet);    //执行super::greet方法时，会调用父类的greet方法
        t.start();
    }
}</code></pre><h2 id="构造器引用"><a href="#构造器引用" class="headerlink" title="构造器引用"></a><font color="red">构造器引用</font></h2><ul>
<li>与方法引用类似，不过方法名为new。如：<strong>Person::new</strong>是Person构造器的一个引用  </li>
<li>可以用数组类型建立构造器引用。如：<strong>int[]::new</strong>，它有一个参数 数组长度。等价于lambda的 <strong>x -&gt; new int[x]</strong>  <blockquote>
<p>Java有一个<strong>限制</strong>，无法构造泛型类型数组，数组构造器引用可以克制这个限制。如：<br>new T[n]会产生错误，因为会改为 new Object[n]<br>假设需要一个Person对象数组。Stream接口有一个toArray方法可以返回Object数组：<strong>Object[] people = stream.toArray();</strong><br>不过需要的是Person引用数组，而不是Object引用数组，可以这样做：<br><strong>Person[] people = stream.toArray(Person[]::new);</strong><br>toArray方法调用这个构造器来得到一个正确类型的数组。  </p>
</blockquote>
</li>
</ul>
<h2 id="再谈lambda"><a href="#再谈lambda" class="headerlink" title="再谈lambda"></a><font color="red">再谈lambda</font></h2><p><strong>lambda表达式有3个部分</strong>：  </p>
<blockquote>
<p>1.一个代码块<br>2.参数<br>3.自由变量的值，这是指非参数而且不在代码中定义的变量。   </p>
</blockquote>
<p>关于代码块及自由变量有一个术语：闭包(closure)。在Java中，lambda表达式就是闭包。</p>
<p>lambda表达式可以捕获外围作用域中变量的值，不过要确保捕获的值是明确定义的。  </p>
<ul>
<li>lambda表达式中，只能引用<strong>值</strong>不会改变的变量。若在lambda中引用变量，而变量可能在外部改变，也是不合法的。即：lambda中捕获的变量必须是<strong>最终变量</strong>  </li>
<li>在lambda中声明与一个局部变量同名的参数或局部变量是不合法的。  </li>
<li>在lambda中使用this关键字，是指创建这个lambda表达式的方法的this参数。  </li>
</ul>
<blockquote>
<p>使用lambda表达式的重点是 <strong>延迟执行</strong>，之所以要延迟执行，有：<br>    1. 在一个单独的线程中运行代码。<br>    2. 多次运行代码。<br>    3. 在算法的适当位置运行代码。(如排序的比较操作)<br>    4. 发生某种情况时执行代码。(如点击了一个按钮，数据到达等)<br>    5. 只在必要时才运行代码。  </p>
</blockquote>
<h3 id="常用函数式接口"><a href="#常用函数式接口" class="headerlink" title="常用函数式接口"></a>常用函数式接口</h3><table>
<thead>
<tr>
<th>函数式接口</th>
<th>参数类型</th>
<th>返回类型</th>
<th>抽象方法名</th>
<th>描述</th>
<th>其他方法</th>
</tr>
</thead>
<tbody><tr>
<td>Runnable</td>
<td>无</td>
<td>void</td>
<td>run</td>
<td>作为无参数或返回值的动作运行</td>
<td></td>
</tr>
<tr>
<td>Supplier<t></t></td>
<td>无</td>
<td>T</td>
<td>get</td>
<td>提供一个T类型的值</td>
<td></td>
</tr>
<tr>
<td>Consumer<t></t></td>
<td>T</td>
<td>void</td>
<td>accept</td>
<td>处理一个T类型的值</td>
<td>andThen</td>
</tr>
<tr>
<td>BiConsumer&lt;T,U&gt;</td>
<td>T, U</td>
<td>void</td>
<td>accept</td>
<td>处理T和U类型的值</td>
<td>andThen</td>
</tr>
<tr>
<td>Function&lt;T, R&gt;</td>
<td>T</td>
<td>R</td>
<td>apply</td>
<td>有一个T类型参数的函数</td>
<td>compose,andThen,identity</td>
</tr>
<tr>
<td>BiFunction&lt;T,U,R&gt;</td>
<td>T,U</td>
<td>R</td>
<td>apply</td>
<td>有T和U类型参数的函数</td>
<td>andThen</td>
</tr>
<tr>
<td>UnaryOperator<t></t></td>
<td>T</td>
<td>T</td>
<td>apply</td>
<td>类型T上的一元操作符</td>
<td>compose,andThen,identity</td>
</tr>
<tr>
<td>BinaryOperator<t></t></td>
<td>T,T</td>
<td>T</td>
<td>apply</td>
<td>类型T上的二元操作符</td>
<td>andThen,maxBy,minBy</td>
</tr>
<tr>
<td>Predicate<t></t></td>
<td>T</td>
<td>boolean</td>
<td>test</td>
<td>布尔值函数</td>
<td>and,or,negate,isEqual</td>
</tr>
<tr>
<td>BiPredicate&lt;T,U&gt;</td>
<td>T,U</td>
<td>boolean</td>
<td>test</td>
<td>有两个参数的布尔值函数</td>
<td>and,or,negate</td>
</tr>
<tr>
<td>### 基本类型的函数式接口</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>函数式接口</th>
<th>参数类型</th>
<th>返回类型</th>
<th>抽象方法名</th>
</tr>
</thead>
<tbody><tr>
<td>BooleanSupplier</td>
<td>none</td>
<td>boolean</td>
<td>getAsBoolean</td>
</tr>
<tr>
<td>PSupplier</td>
<td>none</td>
<td>p</td>
<td>getAsP</td>
</tr>
<tr>
<td>PConsumer</td>
<td>p</td>
<td>void</td>
<td>accept</td>
</tr>
<tr>
<td>OjbPConsumer&lt;T</td>
<td>T,p</td>
<td>void</td>
<td>accept</td>
</tr>
<tr>
<td>PFunction&lt;T</td>
<td>p</td>
<td>T</td>
<td>apply</td>
</tr>
<tr>
<td>PToQFunction</td>
<td>p</td>
<td>q</td>
<td>applyAsQ</td>
</tr>
<tr>
<td>ToPFunction&lt;T</td>
<td>T</td>
<td>p</td>
<td>applyAsP</td>
</tr>
<tr>
<td>ToPBiFunction&lt;T,U&gt;</td>
<td>T,U</td>
<td>p</td>
<td>applyAsP</td>
</tr>
<tr>
<td>PUnaryOperator</td>
<td>p</td>
<td>p</td>
<td>applyAsP</td>
</tr>
<tr>
<td>PBinaryOperator</td>
<td>p,p</td>
<td>p</td>
<td>applyAsP</td>
</tr>
<tr>
<td>PPredicate</td>
<td>p</td>
<td>boolean</td>
<td>test</td>
</tr>
</tbody></table>
<p>注：p,q为int,long,double; P,Q为Int,Long,Double.  </p>
<blockquote>
<p>如果设计自己的接口，其中只有一个抽象方法，可以用@FunctionInterface注解来标记这个接口。  </p>
</blockquote>
<ul>
<li><a href="#back">返回目录</a></li>
</ul>
<h2 id="再谈-Comparator"><a href="#再谈-Comparator" class="headerlink" title="再谈 Comparator"></a>再谈 Comparator</h2><p>……</p>
<div id="innerClass">

<h3 id="3-内部类"><a href="#3-内部类" class="headerlink" title="3.内部类"></a>3.内部类</h3><ul>
<li>内部类方法可以访问该类定义所在的作用域中的数据，包括私有的数据。也可以访问创建它的外围类对象的数据域及<strong>私有数据</strong>。</li>
<li>内部类可以对同一个包中的其他类隐藏。</li>
<li>内部类中声明的所有静态域都必须是final。因为一个静态域只有一个实例，而每个外部对象都分别有一个单独的内部类实例。如果不是final，就可能不是唯一的。  </li>
<li>内部类不能有static方法，</li>
<li>当想要定义一个回调函数且不想编写大量代码时，使用匿名内部类比较便捷。  </li>
<li>只有内部类可以是私有类，常规类只可以是<strong>protected</strong>或<strong>public</strong>。<br>可以使用 <strong>outerObject.new InnerClass(construction parameters)</strong> 语法格式更加明确地编写内部对象的构造器。this通常可以省去。<br>内部类对象的外围类引用被设置为创建内部类对象的方法中的this引用。  </li>
</ul>
<p>可以显式地命名将外围类引用设置为其他的对象。如：TimePrinter是个公有内部类，对于任意的语音时钟都可以构造一个TimePrinter：  </p>
<pre><code>TalkintClock jabberer = new TalkingClock(1000, true);
TalkingClock.TimePrinter listener = jabberer.new TimePrinter();</code></pre><p>需要注意，在外围类的作用域之外，可以用<strong>OuterClass.InnerClass</strong>这样引用内部类。  </p>
<blockquote>
<p>内部类是一种编译器现象，与虚拟器无关。编译器会把内部类翻译成用$分隔外部类名与内部类名的常规类文件，而虚拟机对此一无所知。  </p>
</blockquote>
<p><strong>3.1. 局部内部类：</strong>  </p>
<ul>
<li><p>局部内部类不能用public或private访问说明符进行声明，它的作用域被限定在声明这个局部类的块中。  </p>
</li>
<li><p>局部类对外部世界完全地绝对隐藏起来   </p>
</li>
<li><p>局部类不仅能够访问包含它们地外部类，还可以访问局部变量。但局部变量必须是final，即一旦赋值绝不会改变。<br>假设想更新在一个封闭作用域内地计时器，这时final限制则不太方便。可以使用一个长度为1地数组：</p>
<p>  counter++;        //错误<br>  counter[0]++;        //长度为1的数组</p>
</li>
</ul>
<p><font color="red">3.2. 匿名内部类</font>  </p>
<ul>
<li><p>如果只创建类的一个对象，则可以不用命名。</p>
</li>
<li><p>匿名类没有构造器，而会将构造器参数传递给父类构造器。在实现接口时，不能有任何参数。</p>
<p>  public void start(int interval, boolean beep){</p>
<pre><code>ActionListener listener = new ActionListener(){
    public void actionPerformed(ActionEvent event){
        System.out.println(&quot;&quot; + new Date());
        if(beep) Toolkit.getDefaultToolkit().beep();  
    }
}};
Timer t = new Timer(interval, listener);
t.start();</code></pre><p>  }</p>
</li>
</ul>
<blockquote>
<p>一般Java程序员用匿名内部类实现事件监听器和其他回调。  </p>
</blockquote>
<h3 id="双括号初始化"><a href="#双括号初始化" class="headerlink" title="双括号初始化"></a>双括号初始化</h3><hr>
<blockquote>
<p>如果只需要传递一个数组到一个方法，之后不再需要，则可以使用匿名内部类语法：  </p>
</blockquote>
<pre><code>invite(new ArrayList&lt;String&gt;(){{add("Tom");add("Tony")}});</code></pre><p><strong>外层括号建立了ArrayList的一个匿名子类，内层括号则是一个对象构造块。</strong>  </p>
<blockquote>
<p>生成日志或调试消息时，通常希望包含当前类名。通过 <strong>getClass()</strong> 来实现，不过getClass调用的时this.getClass()，而静态方法没有this。所以应该使用以下表达式：  </p>
</blockquote>
<pre><code>new Object(){}.getClass().getEnclosingClass()    </code></pre><p><strong>new Object(){}</strong>会建立Object的一个匿名子类的一个匿名对象，<strong>getEnclosingClass</strong>则得到其外围类，也就是包含这个静态方法的类。</p>
<p><strong>3.3. 静态内部类</strong>  </p>
<ul>
<li>解决类名冲突：将类定义为另一个类的 内部公有类，可以通过 OuterClass.InnerClass访问它。如果使用内部类只是为了把一个类隐藏在另外一个类的内部，<strong>不需要内部类引用外围类对象时，则可以将内部类声明为static</strong>，以便取消产生的引用。  </li>
<li>只有内部类可以声明为static  </li>
<li>静态内部类可以有静态域和方法。  </li>
</ul>
<h3 id="4-代理"><a href="#4-代理" class="headerlink" title="4. 代理"></a>4. 代理</h3><ul>
<li>代理可以在运行时创建全新的类，这样的代理能够实现指定的接口。且具有下列方法：<ul>
<li>指定接口所需要的全部方法。</li>
<li>Object类中的全部方法，如 toString、equals等。  </li>
</ul>
</li>
<li>然而不能再运行时定义这些方法的新代码，而是要提供一个调用处理器，调用处理器是实现了InvocationHandler接口的类对象。在这个接口中只有一个方法：Object invoke(Object proxy, Method method, Object[] args)  ,无论何时调用代理对象的方法，调用处理器的invoke方法都会被调用，并向其传递Method对象和原始的调用参数。调用处理器必须给出处理调用的方式。</li>
</ul>
<p>创建代理，需要使用Proxy类的newProxyInstance方法,此方法有三个参数 ：  </p>
<ul>
<li><p>一个类加载器，null表示默认的加载器    </p>
</li>
<li><p>一个Class对象数组，每个元素都是需要实现的接口。  </p>
</li>
<li><p>一个调用处理器。 </p>
</li>
<li><p><a href="#back">返回目录</a></p>
</li>
</ul>
<div id="genericClass">

<h2 id="5-泛型"><a href="#5-泛型" class="headerlink" title="5. 泛型"></a><font color="red">5. 泛型</font></h2><ul>
<li>类型参数的好处：使得程序具有更好的可读性和安全性。  </li>
<li>设计泛型类型的目的：允许泛型代码和遗留代码之间能够互操作。  </li>
</ul>
<h4 id="1-泛型类"><a href="#1-泛型类" class="headerlink" title="1.泛型类"></a>1.泛型类</h4><p><strong>定义泛型类Pair：</strong></p>
<pre><code>public class Pair&lt;T&gt;{
    priavte T first,second;
    public Pair() {first = null; second = null;}
    public Pair(T first, T second) {this.first = first; this.second = second;}
    public T getFirst() {return first;}
    public T getSecond() {return second;}
    public void setFirst(T newValue) {first = newValue;}
    public void setSecond(T newValue) {second = newValue;}
}</code></pre><ul>
<li>一个泛型类(generic class)就是具有一个或多个类型变量的类。  </li>
<li>类型变量一般使用大写形式，且比较短。  </li>
<li>泛型类可看作普通类的工厂。用具体的类型替换类型变量就可以实例化泛型类型，如Pair<string>，可以将结果想象成带有构造器的普通类和访问器及更改器方法。</string></li>
</ul>
<h4 id="2-泛型方法"><a href="#2-泛型方法" class="headerlink" title="2.泛型方法"></a>2.泛型方法</h4><p><strong>定义泛型方法：</strong></p>
<pre><code>public static &lt;T&gt; T getMiddle(T...a){    //类型变量放在修饰符后，返回类型前。第二个T为返回类型
    return a[a.length / 2];
}</code></pre><ul>
<li>泛型方法可以定义在普通类或泛型类中  <blockquote>
<p>如果想知道编译器对一个泛型方法调用最终推断出哪种类型：有目的地引入一个错误，并研究所产生的错误消息。</p>
</blockquote>
</li>
</ul>
<h4 id="3-类型变量的限定"><a href="#3-类型变量的限定" class="headerlink" title="3. 类型变量的限定"></a>3. 类型变量的限定</h4><pre><code>&lt;T extends Comparable&gt;    //表示为实现了Comparable接口地类</code></pre><blockquote>
<p>为什么使用extends而不是implements？  </p>
<ul>
<li>表示T应该是绑定类型的子类型。T和绑定类型可以是类，也可以是接口。  </li>
<li>一个类型变量或通配符可以有多个限定：T extends Comparable &amp; Serializable </li>
<li>限定类型用“&amp;”分隔，逗号用来分隔类型变量。  </li>
</ul>
</blockquote>
<ul>
<li>可以根据需要拥有多个接口父类型，但限定中至多有一个类。如果用一个类作为限定，它必须是限定列表中的第一个。  </li>
</ul>
<h4 id="4-泛型代码和虚拟机"><a href="#4-泛型代码和虚拟机" class="headerlink" title="4. 泛型代码和虚拟机"></a>4. 泛型代码和虚拟机</h4><p>虚拟机没有泛型类型对象，在编译阶段会擦除类型变量，并用第一个限定的类型变量替换 (无限定的变量用Object)。Pair<t>的原始类型如：</t></p>
<pre><code>public class Pair{
    priavte Object first, second;
    public Pair(Object first, Object second){
        this.first = first; this.second = second;
    }
    ...
}</code></pre><ul>
<li>为了提高效率，标签接口（如：Serializable）应放在边界列表的末尾。  </li>
</ul>
<h4 id="5-翻译泛型表达式和泛型方法"><a href="#5-翻译泛型表达式和泛型方法" class="headerlink" title="5. 翻译泛型表达式和泛型方法"></a>5. 翻译泛型表达式和泛型方法</h4><p>程序调用泛型方法时，如果擦出返回类型，编译器会插入Employee的强制类型转换，会把这个方法调用翻译为两条虚拟机指令：</p>
<pre><code>Pair&lt;Employee&gt; buddies = ...;
Employee buddy = buddies.getFirst();</code></pre><ul>
<li>对原始方法Pair.getFirst的调用。</li>
<li>将返回的Object类型强制转换为Employee类型。  </li>
</ul>
<p><strong>泛型方法也进行类型擦除：</strong></p>
<pre><code>public static &lt;T extends Comparable&gt; T min(T[] a) </code></pre><p>擦除后：  </p>
<pre><code>public static Comparable min(Comparable[] a)</code></pre><hr>
<h2 id="桥方法"><a href="#桥方法" class="headerlink" title="桥方法"></a><font color="red">桥方法</font></h2><pre><code>Class DateInterval extends Pair&lt;LocalDate&gt;{
    public void setSecond(LocalDate second){
        if(second.compareTo(getFirst()) &gt;= 0)
            super.setSecond(second);
    }
}</code></pre><p>类型擦除后：  </p>
<pre><code>class DateInterval extends Pair{
    public void setSecond(LocalDate second) {...}
    ...
}</code></pre><p>方法的擦除会使得存在另一个方法，即</p>
<pre><code>public void setSecond(Object second)</code></pre><p>此方法的类型参数为Object，而不是LocalDate。</p>
<pre><code>DateInterval interval = new DateInterval(...);
Pair&lt;LocalDate&gt; pair = interval;
pair.setSecond(aDate);</code></pre><blockquote>
<p>这里希望对setSecond的调用具有多态性，并调用最合适的那个方法。由于pair引用DateInterval对象，所以应该调用DateInterval.setSecond。<br>但是类型擦除与多态发生了冲突，此时需要编译器在DateInterval类中生成一个<strong>桥方法</strong>(bridge method)：  </p>
</blockquote>
<pre><code>//setSecond((Date) second)为强制类型转换，使其调用的是DateInterval.setSecond(Date)方法
 public void setSecond (Object second) { setSecond((Date) second); }  </code></pre><ul>
<li>变量pair已经声明为类型Pair<localdate>，并且这个类型只有一个简单的方法setSecond(Object)，虚拟机用pair引用的对象调用这个方法。  </localdate></li>
<li>这个对象时DateInterval类型的，因而将会调用DateInterval.setSecond(Object)方法，这个方法是合成的桥方法。它调用DateInterval.setSecond(Date)。  </li>
</ul>
<p><strong>Java泛型转换：</strong>  </p>
<ul>
<li>虚拟机中没有泛型，只有普通的类和方法。  </li>
<li>所有的类型参数都用它们的限定类型替换。  </li>
<li>桥方法被合成用来保持多态。  </li>
<li>为保持类型安全性，必要时插入强制类型转换。</li>
</ul>
<hr>
<ul>
<li><a href="http://www.importnew.com/24029.html" target="_blank" rel="noopener">Java 泛型详解</a></li>
<li><a href="https://cloud.tencent.com/developer/article/1033693" target="_blank" rel="noopener">10 道 Java 泛型面试题</a></li>
</ul>
<h2 id="约束与局限性（P321）"><a href="#约束与局限性（P321）" class="headerlink" title="约束与局限性（P321）"></a>约束与局限性（P321）</h2><ol>
<li>不能用基本类型实例化类型参数  </li>
<li>运行时类型查询instanceof只适用于原始类型  </li>
<li>不能创建参数化类型的数组，如 Pair<string>[] table = new Pair<string>[10]; //Error。但声明可以  </string></string></li>
<li>Varargs警告：向参数个数可变的方法传递一个泛型类型的实例。添加注解@SuppressWarnings(“unchecked”)或@SafeVarargs标注    </li>
<li>不能实例化类型变量，如 public Pair() {first = new T();}     //Error。类型擦出后T会改为Object </li>
<li>不能构造泛型数组   </li>
<li>不能在静态域或方法中引用类型变量  </li>
<li>不能抛出或捕获泛型类的实例，也不能扩展Throwable。但在异常规范中使用类型变量是允许的:public static <t extends throwable> void doWork(T t) throws T  </t></li>
<li>可以消除对受查异常的检查。Java异常处理原则：必须为所有受查异常提供一个处理器。可以利用泛型消除这个限制</li>
<li>注意擦除后的冲突。泛型规范原则：要想支持擦出的转换，就需要强行限制一个类或类型变量不能同时成为两个接口类型的子类，而这两个接口是同一接口的不同参数化。  </li>
</ol>
<h4 id="6-通配符类型"><a href="#6-通配符类型" class="headerlink" title="6.通配符类型"></a>6.通配符类型</h4><p>通配符类型中，允许类型参数变化。如：  </p>
<pre><code>public static void printBuddies(Pair&lt;? extends Employee&gt; p)</code></pre><p>类型Pair<manager>是Pair&lt;? extends Employee&gt;的子类型。  </manager></p>
<pre><code>Pair&lt;manager&gt; managerBuddies = new Pair(ceo, cfo);
Pair&lt;? extends Employee&gt; wildcardBuddies = managerBuddies;    //OK
wildcardBuddies.setFirst(lowlyEmployee);        //complile-time error</code></pre><p>对setFirst的调用有一个类型错误。类型Pair&lt;? extends Employee&gt;方法应是这样：</p>
<pre><code>? extends Employee getFirst()
void setFirst(? extends Employee)</code></pre><p>这样不可能调用setFirst方法。编译器只知道需要某个Employee的子类型，但不知道具体是什么类型。因此它拒绝传递任何特定的类型。<br>但是getFirst就不存在此问题：将getFirst的返回值赋给一个Employee的引用完全合法。<br>这样可以区分 <strong>安全的访问器方法</strong> 和 <strong>不安全的更改器方法</strong>。  </p>
<p><strong>通配符的超类型限定：</strong><br>? super Manager<br>限制为Manager的所有超类型。<br><font color="red"><strong>带有超类型限定的通配符可以向泛型对象写入，带有子类型限定的通配符可以从泛型对象读取</strong></font>  </p>
<p><strong>无限定通配符</strong><br>Pair&lt;?&gt;，有以下方法：</p>
<pre><code>? getFirst()
void setFirst(?)  </code></pre><ul>
<li>getFirst的返回值只能赋给一个Object。setFirst方法不能被调用，甚至不能用Object调用。  </li>
<li>Pair&lt;?&gt;和Pair的本质不同在于：可以用任意Object对象调用原始Pair类的<strong>setObjecgt</strong>方法。  </li>
<li>可以调用 setFirst(null)</li>
</ul>
<h4 id="7-通配符捕获（P334）"><a href="#7-通配符捕获（P334）" class="headerlink" title="7. 通配符捕获（P334）"></a>7. 通配符捕获（P334）</h4><ul>
<li>通配符捕获只有在有许多限制的情况下才是合法的。</li>
<li>编译器必须能够确信通配符表达的是单个、确定的类型。  </li>
</ul>
<h4 id="8-反射和泛型"><a href="#8-反射和泛型" class="headerlink" title="8. 反射和泛型"></a>8. 反射和泛型</h4><p>对象是泛型类的实例时，泛型类参数会被擦除，得不到太多信息。通过反射可以获得泛型类的信息。  </p>
<p>使用Class<t>参数进行类型匹配。</t></p>
<ul>
<li><a href="#back">返回目录</a>  </li>
</ul>
<div id="Collection">

<h2 id="6-集合"><a href="#6-集合" class="headerlink" title="6. 集合"></a><font color="red">6. 集合</font></h2><h3 id="1-集合框架图"><a href="#1-集合框架图" class="headerlink" title="1. 集合框架图"></a>1. 集合框架图</h3><p><img src="https://i.imgur.com/Q6yC7i7.gif" alt>  </p>
<p><strong>简化图：</strong></p>
<p><img src="https://i.imgur.com/qYlG4pZ.jpg" alt></p>
<p>说明：对于以上的框架图有如下几点说明：</p>
<p>1.所有集合类都位于<strong>java.util</strong>包下。Java的集合类主要由两个接口派生而出：<strong>Collection</strong>和<strong>Map</strong>，Collection和Map是Java集合框架的根接口，这两个接口又包含了一些子接口或实现类。  </p>
<ol start="2">
<li>集合接口：6个接口（短虚线表示），表示不同集合类型，是集合框架的基础。  </li>
<li>抽象类：5个抽象类（长虚线表示），对集合接口的部分实现。可扩展为自定义集合类。  </li>
<li>实现类：8个实现类（实线表示），对接口的具体实现。  </li>
<li><strong>Collection 接口是一组允许重复的对象。</strong>  </li>
<li><strong>Set 接口继承 Collection，集合元素不重复。</strong>  </li>
<li><strong>List 接口继承 Collection，允许重复，维护元素插入顺序。</strong>  </li>
<li><strong>Map接口是键－值对象，与Collection接口没有什么关系。</strong>  </li>
<li>Set、List和Map可以看做集合的三大类：  </li>
</ol>
<ul>
<li><strong>List集合是有序集合，集合中的元素可以重复，访问集合中的元素可以根据元素的索引来访问。</strong>  </li>
<li><strong>Set集合是无序集合，集合中的元素不可重复，访问集合中的元素只能根据元素本身来访问（也是集合里元素不允许重复的原因）。</strong></li>
<li><strong>Map集合中保存Key-value对形式的元素，访问时只能根据每项元素的key来访问其value。</strong>  <h3 id="2-总体分析："><a href="#2-总体分析：" class="headerlink" title="2. 总体分析："></a>2. 总体分析：</h3></li>
</ul>
<p><img src="https://i.imgur.com/dRnCbSO.jpg" alt>  </p>
<p>大致说明：<br>看上面的框架图，先抓住它的主干，即Collection和Map。</p>
<p>1、Collection是一个接口，是高度抽象出来的集合，它包含了集合的基本操作和属性。Collection包含了List和Set两大分支。</p>
<ul>
<li><p>（1）List是一个<strong>有序的队列</strong>，每一个元素都有它的索引。第一个元素的索引值是0。List的实现类有LinkedList, ArrayList, Vector, Stack。</p>
</li>
<li><p>（2）Set是一个<strong>不允许有重复元素的集合</strong>。Set的实现类有HastSet和TreeSet。<strong>HashSet依赖于HashMap，它实际上是通过HashMap实现的；TreeSet依赖于TreeMap，它实际上是通过TreeMap实现的。</strong></p>
</li>
</ul>
<p>2、Map是一个映射接口，即<strong>key-value键值对</strong>。Map中的每一个元素包含“<strong>一个key</strong>”和“<strong>key对应的value</strong>”。AbstractMap是个抽象类，它实现了Map接口中的大部分API。而HashMap，TreeMap，WeakHashMap都是继承于AbstractMap。Hashtable虽然继承于Dictionary，但它实现了Map接口。</p>
<p>3、接下来，再看Iterator。它是<strong>遍历集合的工具</strong>，即我们通常通过Iterator迭代器来遍历集合。我们说Collection依赖于Iterator，是<strong>因为Collection的实现类都要实现iterator()函数，返回一个Iterator对象。**</strong>ListIterator是专门为遍历List而存在的。**</p>
<p>4、再看Enumeration，它是JDK 1.0引入的抽象类。作用和Iterator一样，也是<strong>遍历集合</strong>；但是Enumeration的功能要比Iterator少。在上面的框图中，<strong>Enumeration只能在Hashtable, Vector, Stack中使用。</strong></p>
<p>5、最后，看Arrays和Collections。它们是<strong>操作数组、集合的两个工具类</strong>。</p>
<p>有了上面的整体框架之后，我们接下来对每个类分别进行分析。 </p>
<h3 id="3-Collection接口"><a href="#3-Collection接口" class="headerlink" title="3. Collection接口"></a>3. Collection接口</h3><p>Collection接口是处理对象集合的<strong>根接口</strong>，其中定义了很多对元素进行操作的方法。Collection接口有两个主要的子接口<strong>List</strong>和<strong>Set</strong>，注意<strong>Map不是Collection的子接口</strong>，这个要牢记。  </p>
<p>Collection接口中的方法如下:<br><img src="https://i.imgur.com/A3k1iy6.png" alt></p>
<p>其中，有几个比较常用的方法，比如方法add()添加一个元素到集合中，addAll()将指定集合中的所有元素添加到集合中，contains()方法检测集合中是否包含指定的元素，toArray()方法返回一个表示集合的数组。</p>
<p>另外，Collection中有一个iterator()函数，它的作用是<strong>返回一个Iterator接口</strong>。通常，我们<strong>通过Iterator迭代器来遍历集合</strong>。ListIterator是List接口所特有的，<strong>在List接口中，通过ListIterator()返回一个ListIterator对象</strong>。</p>
<p>Collection接口有两个常用的子接口，下面详细介绍。</p>
<h4 id="3-1-List接口"><a href="#3-1-List接口" class="headerlink" title="3.1 List接口"></a><font color="red">3.1 List接口</font></h4><p><strong>List集合代表一个有序集合，集合中每个元素都有其对应的顺序索引。List集合允许使用重复元素，可以通过索引来访问指定位置的集合元素</strong>。</p>
<p>List接口继承于Collection接口，它可以定义一个<strong>允许重复</strong>的<strong>有序集合</strong>。因为List中的元素是有序的，所以我们可以通过使用索引（元素在List中的位置，类似于数组下标）来访问List中的元素，这类似于Java的数组。</p>
<p>List接口为Collection直接接口。List所代表的是<strong>有序的Collection</strong>，即它用某种特定的插入顺序来维护元素顺序。用户可以对列表中每个元素的插入位置进行精确地控制，同时可以根据元素的整数索引（在列表中的位置）访问元素，并搜索列表中的元素。实现List接口的集合主要有：ArrayList、LinkedList、Vector、Stack。</p>
<ul>
<li><p>（1）ArrayList<br>ArrayList是一个<strong>动态数组</strong>，也是我们最常用的集合。它允许任何符合规则的元素插入甚至包括null。每一个ArrayList都有一个初始容量（10），该容量代表了数组的大小。随着容器中的元素不断增加，容器的大小也会随着增加。在每次向容器中增加元素的同时都会进行容量检查，当快溢出时，就会进行扩容操作。所以<strong>如果我们明确所插入元素的多少，最好指定一个初始容量值，避免过多的进行扩容操作而浪费时间、效率。</strong></p>
<p>  size、isEmpty、get、set、iterator 和 listIterator 操作都以固定时间运行。add 操作以分摊的固定时间运行，也就是说，添加 n 个元素需要 O(n) 时间（由于要考虑到扩容，所以这不只是添加元素会带来分摊固定时间开销那样简单）。</p>
<p>  <strong>ArrayList擅长于随机访问。同时ArrayList是非同步的。</strong></p>
</li>
<li><p>（2）LinkedList<br>同样实现List接口的LinkedList与ArrayList不同，<strong>ArrayList是一个动态数组，而LinkedList是一个双向链表</strong>。所以它除了有ArrayList的基本操作方法外还额外提供了get，remove，insert方法在LinkedList的首部或尾部。</p>
<p>  由于实现的方式不同，<strong>LinkedList不能随机访问</strong>，它所有的操作都是要按照双重链表的需要执行。在列表中索引的操作将从开头或结尾遍历列表（从靠近指定索引的一端）。这样做的好处就是可以通过较低的代价在List中进行插入和删除操作。</p>
<p>  与ArrayList一样，<strong>LinkedList也是非同步的</strong>。如果多个线程同时访问一个List，则必须自己实现访问同步。一种解决方法是在创建List时构造一个同步的List：<br>  List list = Collections.synchronizedList(new LinkedList(…));</p>
</li>
<li><p>（3）Vector<br>与ArrayList相似，但是<strong>Vector是同步的</strong>。所以说<strong>Vector是线程安全的动态数组</strong>。它的操作与ArrayList几乎一样。</p>
</li>
<li><p>（4）Stack<br>Stack继承自Vector，实现一个后进先出的堆栈。Stack提供5个额外的方法使得Vector得以被当作堆栈使用。基本的push和pop 方法，还有peek方法得到栈顶的元素，empty方法测试堆栈是否为空，search方法检测一个元素在堆栈中的位置。Stack刚创建后是空栈。</p>
</li>
</ul>
<p><img src="https://i.imgur.com/3Nd4DC6.png" alt></p>
<h4 id="3-2-Set接口"><a href="#3-2-Set接口" class="headerlink" title="3.2 Set接口"></a><font color="red">3.2 Set接口</font></h4><ul>
<li><p>Set是一种<strong>不包括重复元素的Collection</strong>。它维持它自己的内部排序，所以随机访问没有任何意义。与List一样，它同样允许null的存在但是<strong>仅有一个</strong>。由于Set接口的特殊性， <strong>所有传入Set集合中的元素都必须不同</strong>，同时要注意任何可变对象，如果在对集合中元素进行操作时，导致e1.equals(e2)==true，则必定会产生某些问题。Set接口有三个具体实现类，分别是散列集HashSet、链式散列集LinkedHashSet和树形集TreeSet。</p>
</li>
<li><p><strong>Set是一种不包含重复的元素的Collection，无序，即任意的两个元素e1和e2都有e1.equals(e2)=false，Set最多有一个null元素。需要注意的是:虽然Set中元素没有顺序，但是元素在set中的位置是由该元素的HashCode决定的，其具体位置其实是固定的。</strong></p>
<p>  此外需要说明一点，在set接口中的不重复是有特殊要求的。  </p>
<p>  举一个例子:对象A和对象B，本来是不同的两个对象，正常情况下它们是能够放入到Set里面的，但是如果对象A和B的都重写了hashcode和equals方法，并且重写后的hashcode和equals方法是相同的话。那么A和B是不能同时放入到Set集合中去的，也就是Set集合中的去重和hashcode与equals方法直接相关。 </p>
</li>
</ul>
<p>为了更好地理解，请看下面的例子：</p>
<pre><code>public class Test{ 
public static void main(String[] args) { 
     Set&lt;String&gt; set=new HashSet&lt;String&gt;(); 
     set.add(&quot;Hello&quot;); 
     set.add(&quot;world&quot;); 
     set.add(&quot;Hello&quot;); 
     System.out.println(&quot;集合的尺寸为:&quot;+set.size()); 
     System.out.println(&quot;集合中的元素为:&quot;+set.toString()); 
  } 
}</code></pre><p>运行结果：</p>
<p>集合的尺寸为:2<br>集合中的元素为:[world, Hello]</p>
<p>分析：由于String类中重写了hashcode和equals方法，用来比较指向的字符串对象所存储的字符串是否相等。所以这里的第二个Hello是加不进去的。</p>
<p>再看一个例子：</p>
<pre><code>public class TestSet {

    public static void main(String[] args){

        Set&lt;String&gt; books = new HashSet&lt;String&gt;();
        //添加一个字符串对象
        books.add(new String(&quot;Struts2权威指南&quot;));

        //再次添加一个字符串对象，
        //因为两个字符串对象通过equals方法比较相等，所以添加失败，返回false
        boolean result = books.add(new String(&quot;Struts2权威指南&quot;));

        System.out.println(result);

        //下面输出看到集合只有一个元素
        System.out.println(books);    

    }
}</code></pre><p>运行结果：</p>
<p>false<br>[Struts2权威指南]</p>
<p>说明：程序中，book集合两次添加的字符串对象明显不是一个对象（程序通过new关键字来创建字符串对象），当使用==运算符判断返回false，使用equals方法比较返回true，所以不能添加到Set集合中，最后只能输出一个元素。</p>
<ul>
<li><p>（1）HashSet  </p>
<ul>
<li><p>HashSet 是一个没有重复元素的集合。它是由HashMap实现的，不保证元素的顺序(<strong>这里所说的没有顺序是指：元素插入的顺序与输出的顺序不一致</strong>)，而且HashSet允许使用null 元素。HashSet是非同步的，如果多个线程同时访问一个哈希set，而其中至少一个线程修改了该set，那么它必须保持外部同步。** HashSet按Hash算法来存储集合的元素，因此具有很好的存取和查找性能。**</p>
</li>
<li><p><strong>HashSet的实现方式大致如下，通过一个HashMap存储元素，元素是存放在HashMap的Key中，而Value统一使用一个Object对象。</strong></p>
<p>HashSet使用和理解中容易出现的误区:</p>
</li>
<li><p>a. HashSet中存放null值<br>HashSet中是允许存入null值的，但是在HashSet中仅仅能够存入一个null值。</p>
</li>
<li><p>b.HashSet中存储元素的位置是固定的<br>HashSet中存储的元素的是无序的，这个没什么好说的，但是由于HashSet底层是基于Hash算法实现的，使用了hashcode，所以HashSet中相应的元素的位置是固定的。</p>
</li>
<li><p>c.必须小心操作可变对象（Mutable Object）。如果一个Set中的可变元素改变了自身状态导致Object.equals(Object)=true将导致一些问题。</p>
</li>
</ul>
</li>
<li><p>（2）LinkedHashSet<br>  LinkedHashSet继承自HashSet，其底层是<strong>基于LinkedHashMap来实现的</strong>，有序，非同步。LinkedHashSet集合同样是根据元素的hashCode值来决定元素的存储位置，但是它同时使用链表维护元素的次序。这样使得元素看起来像是以插入顺序保存的，也就是说，当遍历该集合时候，<strong>LinkedHashSet将会以元素的添加顺序访问集合的元素</strong>。</p>
</li>
<li><p>（3）TreeSet<br>TreeSet是一个有序集合，其底层是基于TreeMap实现的，非线程安全。TreeSet可以确保集合元素处于排序状态。TreeSet支持两种排序方式，自然排序和定制排序，其中自然排序为默认的排序方式。当我们构造TreeSet时，若使用不带参数的构造函数，则TreeSet的使用自然比较器；若用户需要使用自定义的比较器，则需要使用带比较器的参数。</p>
</li>
</ul>
<p>注意：TreeSet集合不是通过hashcode和equals函数来比较元素的.它是通过compare或者comparaeTo函数来判断元素是否相等.compare函数通过判断两个对象的id，相同的id判断为重复元素，不会被加入到集合中。</p>
<h3 id="4-Map接口"><a href="#4-Map接口" class="headerlink" title="4. Map接口"></a><font color="red">4. Map接口</font></h3><ul>
<li>Map与List、Set接口不同，它是由一系列键值对组成的集合，提供了key到Value的映射。同时它也没有继承Collection。  </li>
<li>在Map中它保证了key与value之间的一一对应关系。也就是说一个key对应一个value，所以它<strong>不能存在相同的key值，当然value值可以相同。</strong></li>
</ul>
<h4 id="4-1-HashMap"><a href="#4-1-HashMap" class="headerlink" title="4.1 HashMap"></a>4.1 HashMap</h4><ul>
<li>以哈希表数据结构实现，查找对象时通过哈希函数计算其位置，它是为快速查询而设计的，其内部定义了一个hash表数组（Entry[] table），元素会通过哈希转换函数将元素的哈希地址转换成数组中存放的索引，如果有冲突，则使用散列链表的形式将所有相同哈希地址的元素串起来，可能通过查看HashMap.Entry的源码它是一个单链表结构。</li>
</ul>
<h4 id="4-2-LinkedHashMap"><a href="#4-2-LinkedHashMap" class="headerlink" title="4.2 LinkedHashMap"></a>4.2 LinkedHashMap</h4><ul>
<li><p>LinkedHashMap是HashMap的一个子类，它保留插入的顺序，如果需要输出的顺序和输入时的相同，那么就选用LinkedHashMap。</p>
</li>
<li><p>LinkedHashMap是Map接口的哈希表和链接列表实现，具有可预知的迭代顺序。此实现提供所有可选的映射操作，并允许使用null值和null键。此类不保证映射的顺序，特别是它不保证该顺序恒久不变。</p>
</li>
<li><p>LinkedHashMap实现与HashMap的不同之处在于，后者维护着一个运行于所有条目的双重链接列表。此链接列表定义了迭代顺序，该迭代顺序可以是插入顺序或者是访问顺序。</p>
</li>
<li><p>根据链表中元素的顺序可以分为：按插入顺序的链表，和按访问顺序(调用get方法)的链表。默认是按插入顺序排序，如果指定按访问顺序排序，那么调用get方法后，会将这次访问的元素移至链表尾部，不断访问可以形成按访问顺序排序的链表。  </p>
<p>  注意，此实现不是同步的。如果多个线程同时访问链接的哈希映射，而其中至少一个线程从结构上修改了该映射，则它必须保持外部同步。</p>
<p>  由于LinkedHashMap需要维护元素的插入顺序，因此性能略低于HashMap的性能，但在迭代访问Map里的全部元素时将有很好的性能，因为它以链表来维护内部顺序。</p>
</li>
</ul>
<h4 id="4-3-TreeMap"><a href="#4-3-TreeMap" class="headerlink" title="4.3 TreeMap"></a>4.3 TreeMap</h4><ul>
<li><p>TreeMap 是一个有序的key-value集合，非同步，基于红黑树（Red-Black tree）实现，每一个key-value节点作为红黑树的一个节点。TreeMap存储时会进行排序的，会根据key来对key-value键值对进行排序，其中排序方式也是分为两种，一种是自然排序，一种是定制排序，具体取决于使用的构造方法。</p>
</li>
<li><p>自然排序：TreeMap中所有的key必须实现Comparable接口，并且所有的key都应该是同一个类的对象，否则会报ClassCastException异常。</p>
</li>
<li><p>定制排序：定义TreeMap时，创建一个comparator对象，该对象对所有的treeMap中所有的key值进行排序，采用定制排序的时候不需要TreeMap中所有的key必须实现Comparable接口。</p>
</li>
<li><p>TreeMap判断两个元素相等的标准：<strong>两个key通过compareTo()方法返回0，则认为这两个key相等。</strong></p>
</li>
</ul>
<p>如果使用自定义的类来作为TreeMap中的key值，且想让TreeMap能够良好的工作，则必须重写自定义类中的equals()方法，TreeMap中判断相等的标准是：两个key通过equals()方法返回为true，并且通过compareTo()方法比较应该返回为0。<br><img src="https://i.imgur.com/AddxEF1.png" alt></p>
<ul>
<li><a href="#back">返回目录</a></li>
</ul>
<h3 id="5-Iterator-与-ListIterator详解"><a href="#5-Iterator-与-ListIterator详解" class="headerlink" title="5. Iterator 与 ListIterator详解"></a><font color="red">5. Iterator 与 ListIterator详解</font></h3><h4 id="5-1-Iterator"><a href="#5-1-Iterator" class="headerlink" title="5.1 Iterator"></a>5.1 Iterator</h4><p>Iterator的定义如下：  </p>
<pre><code>public interface Iterator&lt;E&gt; {}  </code></pre><p>Iterator是一个接口，它是集合的迭代器。集合可以通过Iterator去遍历集合中的元素。Iterator提供的API接口如下：</p>
<ul>
<li>boolean hasNext()：判断集合里是否存在下一个元素。如果有，hasNext()方法返回 true。  </li>
<li>Object next()：返回集合里下一个元素。  </li>
<li>void remove()：删除集合里上一次next方法返回的元素。  </li>
</ul>
<p>使用示例：  </p>
<pre><code>public class IteratorExample {
    public static void main(String[] args) {
        ArrayList&lt;String&gt; a = new ArrayList&lt;String&gt;();
        a.add(&quot;aaa&quot;);
        a.add(&quot;bbb&quot;);
        a.add(&quot;ccc&quot;);
        System.out.println(&quot;Before iterate : &quot; + a);
        Iterator&lt;String&gt; it = a.iterator();
        while (it.hasNext()) {
            String t = it.next();
            if (&quot;bbb&quot;.equals(t)) {
                it.remove();
            }
        }
        System.out.println(&quot;After iterate : &quot; + a);
    }
}</code></pre><p>输出结果如下：  </p>
<pre><code>Before iterate : [aaa, bbb, ccc]
After iterate : [aaa, ccc] </code></pre><p>注意：</p>
<ul>
<li><p>（1）Iterator只能单向移动。</p>
</li>
<li><p>（2）Iterator.remove()是唯一安全的方式来在迭代过程中修改集合；如果在迭代过程中以任何其它的方式修改了基本集合将会产生未知的行为。而且每调用一次next()方法，remove()方法只能被调用一次，如果违反这个规则将抛出一个异常。</p>
</li>
</ul>
<h4 id="5-2-ListIterator"><a href="#5-2-ListIterator" class="headerlink" title="5.2 ListIterator"></a>5.2 ListIterator</h4><ul>
<li>ListIterator是一个功能更加强大的迭代器, 它继承于Iterator接口,只能用于各种List类型的访问。可以通过调用listIterator()方法产生一个指向List开始处的ListIterator, 还可以调用listIterator(n)方法创建一个一开始就指向列表索引为n的元素处的ListIterator.</li>
</ul>
<p>ListIterator接口定义如下:  </p>
<pre><code>public interface ListIterator&lt;E&gt; extends Iterator&lt;E&gt; {
    boolean hasNext();

    E next();

    boolean hasPrevious();

    E previous();

    int nextIndex();

    int previousIndex();

    void remove();

    void set(E e);

    void add(E e);

}</code></pre><p>由以上定义我们可以推出ListIterator可以:</p>
<ul>
<li><p>(1)双向移动（向前/向后遍历）.</p>
</li>
<li><p>(2)产生相对于迭代器在列表中指向的当前位置的前一个和后一个元素的索引.</p>
</li>
<li><p>(3)可以使用set()方法替换它访问过的最后一个元素.</p>
</li>
<li><p>(4)可以使用add()方法在next()方法返回的元素之前或previous()方法返回的元素之后插入一个元素.</p>
</li>
</ul>
<p>使用示例：  </p>
<pre><code>public class ListIteratorExample {

    public static void main(String[] args) {
        ArrayList&lt;String&gt; a = new ArrayList&lt;String&gt;();
        a.add(&quot;aaa&quot;);
        a.add(&quot;bbb&quot;);
        a.add(&quot;ccc&quot;);
        System.out.println(&quot;Before iterate : &quot; + a);
        ListIterator&lt;String&gt; it = a.listIterator();
        while (it.hasNext()) {
            System.out.println(it.next() + &quot;, &quot; + it.previousIndex() + &quot;, &quot; + it.nextIndex());
        }
        while (it.hasPrevious()) {
            System.out.print(it.previous() + &quot; &quot;);
        }
        System.out.println();
        it = a.listIterator(1);
        while (it.hasNext()) {
            String t = it.next();
            System.out.println(t);
            if (&quot;ccc&quot;.equals(t)) {
                it.set(&quot;nnn&quot;);
            } else {
                it.add(&quot;kkk&quot;);
            }
        }
        System.out.println(&quot;After iterate : &quot; + a);
    }
}</code></pre><p>输出结果如下：  </p>
<pre><code>Before iterate : [aaa, bbb, ccc]
aaa, 0, 1
bbb, 1, 2
ccc, 2, 3
ccc bbb aaa 
bbb
ccc
After iterate : [aaa, bbb, kkk, nnn]</code></pre><h3 id="6-异同点"><a href="#6-异同点" class="headerlink" title="6. 异同点"></a><font color="red">6. 异同点</font></h3><h4 id="6-1ArrayList和LinkedList"><a href="#6-1ArrayList和LinkedList" class="headerlink" title="6.1ArrayList和LinkedList"></a>6.1ArrayList和LinkedList</h4><ul>
<li>（1）ArrayList是实现了基于动态数组的数据结构，LinkedList基于链表的数据结构。 </li>
<li>（2）对于随机访问get和set，ArrayList绝对优于LinkedList，因为LinkedList要移动指针。 </li>
<li>（3）对于新增和删除操作add和remove，LinedList比较占优势，因为ArrayList要移动数据。   </li>
</ul>
<p>这一点要看实际情况的。若只对单条数据插入或删除，ArrayList的速度反而优于LinkedList。<br>但若是批量随机的插入删除数据，LinkedList的速度大大优于ArrayList。因为ArrayList每插入一条数据，要移动插入点及之后的所有数据。</p>
<h4 id="6-2-HashTable与HashMap"><a href="#6-2-HashTable与HashMap" class="headerlink" title="6.2 HashTable与HashMap"></a>6.2 HashTable与HashMap</h4><p><strong>相同点</strong>：</p>
<ul>
<li>（1）都实现了Map、Cloneable、java.io.Serializable接口。  </li>
<li>（2）都是存储”键值对(key-value)”的散列表，而且都是采用拉链法实现的。</li>
</ul>
<p><strong>不同点</strong>：</p>
<ul>
<li><p>（1）历史原因:HashTable是基于陈旧的Dictionary类的，HashMap是Java 1.2引进的Map接口的一个实现 。</p>
</li>
<li><p>（2）同步性:HashTable是线程安全的，也就是说是同步的，而HashMap是线程序不安全的，不是同步的 。</p>
</li>
<li><p>（3）对null值的处理：HashMap的key、value都可为null，HashTable的key、value都不可为null 。</p>
</li>
<li><p>（4）基类不同：HashMap继承于AbstractMap，而Hashtable继承于Dictionary。</p>
<blockquote>
<p>Dictionary是一个抽象类，它直接继承于Object类，没有实现任何接口。Dictionary类是JDK 1.0的引入的。</p>
<p>虽然Dictionary也支持“添加key-value键值对”、“获取value”、“获取大小”等基本操作，但它的API函数比Map少；而且Dictionary一般是通过Enumeration(枚举类)去遍历，Map则是通过Iterator(迭代M器)去遍历。   </p>
</blockquote>
<blockquote>
<p>然而由于Hashtable也实现了Map接口，所以，它即支持Enumeration遍历，也支持Iterator遍历。 </p>
</blockquote>
<blockquote>
<p>AbstractMap是一个抽象类，它实现了Map接口的绝大部分API函数；为Map的具体实现类提供了极大的便利。它是JDK 1.2新增的类。</p>
</blockquote>
</li>
<li><p>（5）支持的遍历种类不同：HashMap只支持Iterator(迭代器)遍历。而Hashtable支持Iterator(迭代器)和Enumeration(枚举器)两种方式遍历。</p>
</li>
</ul>
<h4 id="6-3-HashMap、Hashtable、LinkedHashMap和TreeMap比较"><a href="#6-3-HashMap、Hashtable、LinkedHashMap和TreeMap比较" class="headerlink" title="6.3 HashMap、Hashtable、LinkedHashMap和TreeMap比较"></a>6.3 HashMap、Hashtable、LinkedHashMap和TreeMap比较</h4><ul>
<li><p>Hashmap 是一个最常用的Map，它<strong>根据键的HashCode 值存储数据</strong>，根据键可以直接获取它的值，<strong>具有很快的访问速度</strong>。遍历时，<strong>取得数据的顺序是完全随机的</strong>。HashMap最多只允许<strong>一条记录的键为Null</strong>;允许多条记录的值为Null;HashMap<strong>不支持线程的同步</strong>，即任一时刻可以有多个线程同时写HashMap;可能会导致数据的不一致。如果需要同步，可以用Collections的synchronizedMap方法使HashMap具有同步的能力。</p>
</li>
<li><p>Hashtable 与 HashMap类似，不同的是:它<strong>不允许记录的键或者值为空</strong>;它<strong>支持线程的同步</strong>，即任一时刻只有一个线程能写Hashtable，因此也导致了Hashtale在写入时会比较慢。</p>
</li>
</ul>
<ul>
<li><p>LinkedHashMap<strong>保存了记录的插入顺序</strong>，在用Iterator遍历LinkedHashMap时，<strong>先得到的记录肯定是先插入的</strong>，也可以在构造时用带参数，按照应用次数排序。在遍历的时候会比HashMap慢，不过有种情况例外，当HashMap容量很大，实际数据较少时，遍历起来可能会比LinkedHashMap慢，因为LinkedHashMap的遍历速度只和实际数据有关，和容量无关，而HashMap的遍历速度和他的容量有关。<strong>如果需要输出的顺序和输入的相同，那么用LinkedHashMap可以实现</strong>，它还可以按读取顺序来排列，像连接池中可以应用。  </p>
<p> LinkedHashMap实现与HashMap的不同之处在于，后者维护着一个运行于所有条目的双重链表。此链接列表定义了迭代顺序，<strong>该迭代顺序可以是插入顺序或者是访问顺序</strong>。对于LinkedHashMap而言，它继承与HashMap、底层<strong>使用哈希表与双向链表来保存所有元素</strong>。其基本操作与父类HashMap相似，它通过重写父类相关的方法，来实现自己的链接列表特性。</p>
<ul>
<li>TreeMap实现SortMap接口，内部实现是<strong>红黑树</strong>。能够把它保存的记录根据<strong>键排序</strong>，<strong>默认是按键值的**</strong>升序排序<strong>，也可以指定排序的比较器，当</strong>用Iterator 遍历TreeMap时<strong>，</strong>得到的记录是排过序的。TreeMap不允许key的值为null。非同步的。** </li>
</ul>
</li>
<li><p>一般情况下，我们用的最多的是HashMap，HashMap里面存入的键值对在取出的时候是随机的，它根据键的HashCode值存储数据，根据键可以直接获取它的值，具有很快的访问速度。在Map 中插入、删除和定位元素，HashMap 是最好的选择。<br>TreeMap取出来的是排序后的键值对。但如果要<strong>按自然顺序或自定义顺序遍历键</strong>，那么TreeMap会更好。<br>LinkedHashMap 是HashMap的一个子类，如果需要<strong>输出的顺序和输入的相同</strong>，那么用LinkedHashMap可以实现，它还可以按读取顺序来排列，像连接池中可以应用。 </p>
<pre><code>import java.util.HashMap;
import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.TreeMap;

public class MapTest {

    public static void main(String[] args) {

        //HashMap
        HashMap&lt;String,String&gt; hashMap = new HashMap();
        hashMap.put(&quot;4&quot;, &quot;d&quot;);
        hashMap.put(&quot;3&quot;, &quot;c&quot;);
        hashMap.put(&quot;2&quot;, &quot;b&quot;);
        hashMap.put(&quot;1&quot;, &quot;a&quot;);

        Iterator&lt;String&gt; iteratorHashMap = hashMap.keySet().iterator();

        System.out.println(&quot;HashMap--&gt;&quot;);

        while (iteratorHashMap.hasNext()){

            Object key1 = iteratorHashMap.next();
            System.out.println(key1 + &quot;--&quot; + hashMap.get(key1));
        }

        //LinkedHashMap
        LinkedHashMap&lt;String,String&gt; linkedHashMap = new LinkedHashMap();
        linkedHashMap.put(&quot;4&quot;, &quot;d&quot;);
        linkedHashMap.put(&quot;3&quot;, &quot;c&quot;);
        linkedHashMap.put(&quot;2&quot;, &quot;b&quot;);
        linkedHashMap.put(&quot;1&quot;, &quot;a&quot;);

        Iterator&lt;String&gt; iteratorLinkedHashMap = linkedHashMap.keySet().iterator();

        System.out.println(&quot;LinkedHashMap--&gt;&quot;);

        while (iteratorLinkedHashMap.hasNext()){

            Object key2 = iteratorLinkedHashMap.next();
            System.out.println(key2 + &quot;--&quot; + linkedHashMap.get(key2));
        }

        //TreeMap
        TreeMap&lt;String,String&gt; treeMap = new TreeMap();
        treeMap.put(&quot;4&quot;, &quot;d&quot;);
        treeMap.put(&quot;3&quot;, &quot;c&quot;);
        treeMap.put(&quot;2&quot;, &quot;b&quot;);
        treeMap.put(&quot;1&quot;, &quot;a&quot;);

        Iterator&lt;String&gt; iteratorTreeMap = treeMap.keySet().iterator();

        System.out.println(&quot;TreeMap--&gt;&quot;);

        while (iteratorTreeMap.hasNext()){

            Object key3 = iteratorTreeMap.next();
            System.out.println(key3 + &quot;--&quot; + treeMap.get(key3));
        }

    }

}</code></pre><p>输出结果为：  </p>
<p>  HashMap–&gt;<br>  3–c<br>  2–b<br>  1–a<br>  4–d<br>  LinkedHashMap–&gt;<br>  4–d<br>  3–c<br>  2–b<br>  1–a<br>  TreeMap–&gt;<br>  1–a<br>  2–b<br>  3–c<br>  4–d</p>
</li>
</ul>
<h4 id="6-4-HashSet、LinkedHashSet、TreeSet比较"><a href="#6-4-HashSet、LinkedHashSet、TreeSet比较" class="headerlink" title="6.4 HashSet、LinkedHashSet、TreeSet比较"></a>6.4 HashSet、LinkedHashSet、TreeSet比较</h4><ul>
<li><p>Set接口<br>Set不允许包含相同的元素，如果试图把两个相同元素加入同一个集合中，add方法返回false。<br>Set判断两个对象相同不是使用==运算符，而是根据equals方法。也就是说，只要两个对象用equals方法比较返回true，Set就不会接受这两个对象。</p>
</li>
<li><p>HashSet<br>HashSet有以下特点：</p>
</li>
<li><blockquote>
<p> 不能保证元素的排列顺序，顺序有可能发生变化。</p>
</blockquote>
</li>
<li><blockquote>
<p> 不是同步的。</p>
</blockquote>
</li>
<li><blockquote>
<p> 集合元素可以是null，但只能放入一个null。<br>   当向HashSet结合中存入一个元素时，HashSet会调用该对象的hashCode()方法来得到该对象的hashCode值，然后根据 hashCode值来决定该对象在HashSet中存储位置。<br>   简单的说，HashSet集合判断两个元素相等的标准是两个对象通过equals方法比较相等，并且两个对象的hashCode()方法返回值也相等。<br>   注意，如果要把一个对象放入HashSet中，重写该对象对应类的equals方法，也应该重写其hashCode()方法。其规则是如果两个对象通过equals方法比较返回true时，其hashCode也应该相同。<br>   另外，对象中用作equals比较标准的属性，都应该用来计算 hashCode的值。</p>
</blockquote>
</li>
<li><p>LinkedHashSet<br>  LinkedHashSet集合同样是根据元素的hashCode值来决定元素的存储位置，但是它同时使用链表维护元素的次序。这样使得元素看起来像是以插入顺序保存的，也就是说，当遍历该集合时候，LinkedHashSet将会以元素的添加顺序访问集合的元素。<br>  LinkedHashSet在迭代访问Set中的全部元素时，性能比HashSet好，但是插入时性能稍微逊色于HashSet。  </p>
</li>
<li><p>TreeSet类<br>  TreeSet是SortedSet接口的唯一实现类，TreeSet可以确保集合元素处于排序状态。<br>  TreeSet支持两种排序方式，自然排序和定制排序，其中自然排序为默认的排序方式。向TreeSet中加入的应该是同一个类的对象。<br>  TreeSet判断两个对象不相等的方式是两个对象通过equals方法返回false，或者通过CompareTo方法比较没有返回0。  </p>
</li>
<li><p>自然排序<br>  自然排序使用要排序元素的CompareTo（Object obj）方法来比较元素之间大小关系，然后将元素按照升序排列。<br>  Java提供了一个Comparable接口，该接口里定义了一个compareTo(Object obj)方法，该方法返回一个整数值，实现了该接口的对象就可以比较大小。obj1.compareTo(obj2)方法如果返回0，则说明被比较的两个对象相等，如果返回一个正数，则表明obj1大于obj2，如果是负数，则表明obj1小于obj2。如果我们将两个对象的equals方法总是返回true，则这两个对象的compareTo方法返回应该返回0。  </p>
</li>
<li><p>定制排序<br>  自然排序是根据集合元素的大小，以升序排列，如果要定制排序，应该使用Comparator接口，实现 int compare(T o1,T o2)方法。  </p>
<pre><code>package com.test;  
import java.util.HashSet;  
import java.util.LinkedHashSet;  
import java.util.TreeSet;  

/**  
 * @description 几个set的比较  
 *    HashSet：哈希表是通过使用称为散列法的机制来存储信息的，元素并没有以某种特定顺序来存放；  
 *    LinkedHashSet：以元素插入的顺序来维护集合的链接表，允许以插入的顺序在集合中迭代；  
 *    TreeSet：提供一个使用树结构存储Set接口的实现，对象以升序顺序存储，访问和遍历的时间很快。  
 * @author Zhou-Jingxian  
 *  
 */  
public class SetDemo {  

    public static void main(String[] args) {  

        HashSet&lt;String&gt; hs = new HashSet&lt;String&gt;();  
        hs.add(&quot;B&quot;);  
        hs.add(&quot;A&quot;);  
        hs.add(&quot;D&quot;);  
        hs.add(&quot;E&quot;);  
        hs.add(&quot;C&quot;);  
        hs.add(&quot;F&quot;);  
        System.out.println(&quot;HashSet 顺序:\n&quot;+hs);  

        LinkedHashSet&lt;String&gt; lhs = new LinkedHashSet&lt;String&gt;();  
        lhs.add(&quot;B&quot;);  
        lhs.add(&quot;A&quot;);  
        lhs.add(&quot;D&quot;);  
        lhs.add(&quot;E&quot;);  
        lhs.add(&quot;C&quot;);  
        lhs.add(&quot;F&quot;);  
        System.out.println(&quot;LinkedHashSet 顺序:\n&quot;+lhs);  

        TreeSet&lt;String&gt; ts = new TreeSet&lt;String&gt;();  
        ts.add(&quot;B&quot;);  
        ts.add(&quot;A&quot;);  
        ts.add(&quot;D&quot;);  
        ts.add(&quot;E&quot;);  
        ts.add(&quot;C&quot;);  
        ts.add(&quot;F&quot;);  
        System.out.println(&quot;TreeSet 顺序:\n&quot;+ts);  
    }  
}</code></pre><p>输出结果：  </p>
<p>  HashSet 顺序:[D, E, F, A, B, C]<br>  LinkedHashSet 顺序:[B, A, D, E, C, F]<br>  TreeSet 顺序:[A, B, C, D, E, F]</p>
<h4 id="6-5-Iterator和ListIterator区别"><a href="#6-5-Iterator和ListIterator区别" class="headerlink" title="6.5 Iterator和ListIterator区别"></a>6.5 Iterator和ListIterator区别</h4></li>
</ul>
<p>我们在使用List，Set的时候，为了实现对其数据的遍历，我们经常使用到了Iterator(迭代器)。使用迭代器，不需要干涉其遍历的过程，只需要每次取出一个想要的数据进行处理就可以了。但是在使用的时候也是有不同的。  </p>
<p>List和Set都有iterator()来取得其迭代器。对List来说，也可以通过listIterator()取得其迭代器，两种迭代器在有些时候是不能通用的，Iterator和ListIterator主要区别在以下方面：</p>
<ul>
<li>（1）ListIterator有add()方法，可以向List中添加对象，而Iterator不能</li>
<li>（2）ListIterator和Iterator都有hasNext()和next()方法，可以实现顺序向后遍历，但是ListIterator有hasPrevious()和previous()方法，可以实现逆向（顺序向前）遍历。Iterator就不可以。</li>
<li>（3）ListIterator可以定位当前的索引位置，nextIndex()和previousIndex()可以实现。Iterator没有此功能。</li>
<li>（4）都可实现删除对象，但是ListIterator可以实现对象的修改，set()方法可以实现。Iierator仅能遍历，不能修改。<br>因为ListIterator的这些功能，可以实现对LinkedList等List数据结构的操作。其实，数组对象也可以用迭代器来实现。</li>
</ul>
<h4 id="6-6-Collection-和-Collections区别"><a href="#6-6-Collection-和-Collections区别" class="headerlink" title="6.6 Collection 和 Collections区别"></a>6.6 Collection 和 Collections区别</h4><ul>
<li><p>（1）java.util.Collection 是一个集合接口（集合类的一个顶级接口）。它提供了对集合对象进行基本操作的通用接口方法。Collection接口在Java 类库中有很多具体的实现。Collection接口的意义是为各种具体的集合提供了最大化的统一操作方式，其直接继承接口有List与Set。</p>
<p>   Collection<br>  ├List<br>  │├LinkedList<br>  │├ArrayList<br>  │└Vector<br>  │　└Stack<br>  └Set   </p>
</li>
<li><p>（2）java.util.Collections 是一个包装类（工具类/帮助类）。它包含有各种有关集合操作的静态多态方法。此类不能实例化，就像一个工具类，用于对集合中元素进行排序、搜索以及线程安全等各种操作，服务于Java的Collection框架。<br>代码示例：  </p>
<pre><code>import java.util.ArrayList; 
import java.util.Collections; 
import java.util.List; 

public class TestCollections { 

    public static void main(String args[]) { 
        //注意List是实现Collection接口的 
        List list = new ArrayList(); 
        double array[] = { 112, 111, 23, 456, 231 }; 
        for (int i = 0; i &lt; array.length; i++) { 
            list.add(new Double(array[i])); 
        } 
        Collections.sort(list); 
        for (int i = 0; i &lt; array.length; i++) { 
            System.out.println(list.get(i)); 
        } 
        // 结果：23.0 111.0 112.0 231.0 456.0 
    } 
}</code></pre></li>
<li><p><a href="#back">返回目录</a></p>
</li>
</ul>
<div id="thread">

<h2 id="7-多线程"><a href="#7-多线程" class="headerlink" title="7. 多线程"></a><font color="red">7. 多线程</font></h2><ul>
<li><p><a href="https://www.cnblogs.com/yjd_hycf_space/p/7526608.html" target="_blank" rel="noopener">Java多线程学习（总结很详细！！！）</a></p>
</li>
<li><p><a href="https://www.cnblogs.com/wxd0108/p/5479442.html" target="_blank" rel="noopener">Java中的多线程你只要看这一篇就够了</a></p>
</li>
</ul>
</div></div></div></div></div></div></div></div></div>
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Java/" rel="tag"># Java</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/09/07/spring/" rel="next" title="Spring基础知识">
                <i class="fa fa-chevron-left"></i> Spring基础知识
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/09/07/MySQL/" rel="prev" title="MySQL基础知识">
                MySQL基础知识 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">shiysin</p>
              <p class="site-description motion-element" itemprop="description">热爱一切美好事物</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">6</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">6</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">14</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-数据类型"><span class="nav-number">1.</span> <span class="nav-text">1.数据类型</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-1-整形"><span class="nav-number">1.1.</span> <span class="nav-text">1.1 整形</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1-2-浮点类型"><span class="nav-number">1.2.</span> <span class="nav-text">1.2 浮点类型</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1-3char-类型"><span class="nav-number">1.3.</span> <span class="nav-text">1.3char 类型</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1-4-boolean类型"><span class="nav-number">1.4.</span> <span class="nav-text">1.4 boolean类型</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-变量"><span class="nav-number">2.</span> <span class="nav-text">2. 变量</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#2-1-常量"><span class="nav-number">2.1.</span> <span class="nav-text">2.1 常量</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-运算符"><span class="nav-number">3.</span> <span class="nav-text">3. 运算符</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#3-1-Math数学函数与常量"><span class="nav-number">3.1.</span> <span class="nav-text">3.1 Math数学函数与常量</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-2-自增自减运算"><span class="nav-number">3.2.</span> <span class="nav-text">3.2 自增自减运算</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-3-位运算符"><span class="nav-number">3.3.</span> <span class="nav-text">3.3 位运算符</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-4-运算符级别"><span class="nav-number">3.4.</span> <span class="nav-text">3.4 运算符级别</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-1-字符串"><span class="nav-number">3.5.</span> <span class="nav-text">4.1 字符串</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-2-空串-和-null"><span class="nav-number">3.6.</span> <span class="nav-text">4.2 空串 和 null</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-3-String-StringBuilder-StringBuffer-的区别"><span class="nav-number">3.7.</span> <span class="nav-text">4.3 String / StringBuilder / StringBuffer 的区别</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-4-输入输出"><span class="nav-number">3.8.</span> <span class="nav-text">4.4 输入输出</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-5-格式化输入"><span class="nav-number">3.9.</span> <span class="nav-text">4.5 格式化输入</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-控制流程"><span class="nav-number">4.</span> <span class="nav-text">5. 控制流程 </span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#5-1-控制流程语句"><span class="nav-number">4.1.</span> <span class="nav-text">5.1 控制流程语句</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-2-大数值BigInteger-BigDecimal"><span class="nav-number">4.2.</span> <span class="nav-text">5.2 大数值BigInteger / BigDecimal </span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-3-数组-foreach循环"><span class="nav-number">4.3.</span> <span class="nav-text">5.3 数组 foreach循环</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-4-命令行参数"><span class="nav-number">4.4.</span> <span class="nav-text">5.4 命令行参数</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#数组排序"><span class="nav-number">5.</span> <span class="nav-text">***数组排序 </span></a></li></ol><li class="nav-item nav-level-2"><a class="nav-link" href="#2-对象与类"><span class="nav-number"></span> <span class="nav-text">2.对象与类</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-类"><span class="nav-number">1.</span> <span class="nav-text">1. 类</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-1-更改器方法-与-访问器方法"><span class="nav-number">1.1.</span> <span class="nav-text">1.1 更改器方法 与 访问器方法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1-2-构造器"><span class="nav-number">1.2.</span> <span class="nav-text">1.2 构造器</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1-3-隐式参数和显式参数"><span class="nav-number">1.3.</span> <span class="nav-text">1.3 隐式参数和显式参数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1-4-封装的优点"><span class="nav-number">1.4.</span> <span class="nav-text">1.4 封装的优点</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1-5-私有方法"><span class="nav-number">1.5.</span> <span class="nav-text">1.5 私有方法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1-6-final实力域"><span class="nav-number">1.6.</span> <span class="nav-text">1.6 final实力域</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1-7-静态域与静态方法"><span class="nav-number">1.7.</span> <span class="nav-text">1.7 静态域与静态方法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1-8-工厂方法"><span class="nav-number">1.8.</span> <span class="nav-text">1.8 工厂方法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1-9-main方法"><span class="nav-number">1.9.</span> <span class="nav-text">1.9 main方法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1-10-方法参数"><span class="nav-number">1.10.</span> <span class="nav-text">1.10 方法参数</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-对象构造"><span class="nav-number">2.</span> <span class="nav-text">2.对象构造</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#2-1-重载"><span class="nav-number">2.1.</span> <span class="nav-text">2.1 重载</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-2-默认域初始化"><span class="nav-number">2.2.</span> <span class="nav-text">2.2 默认域初始化</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-3-参数名"><span class="nav-number">2.3.</span> <span class="nav-text">2.3 参数名</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-4-初始化块"><span class="nav-number">2.4.</span> <span class="nav-text">2.4 初始化块</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-5-finalize方法"><span class="nav-number">2.5.</span> <span class="nav-text">2.5 finalize方法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-6-包"><span class="nav-number">2.6.</span> <span class="nav-text">2.6 包</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3。-注释"><span class="nav-number">3.</span> <span class="nav-text">3。 注释</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#类的设计技巧"><span class="nav-number"></span> <span class="nav-text">类的设计技巧</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-继承"><span class="nav-number"></span> <span class="nav-text">3.继承</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-hashCode"><span class="nav-number">1.</span> <span class="nav-text">3. hashCode</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-toString"><span class="nav-number">2.</span> <span class="nav-text">4. toString</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-泛型数组列表ArrayList-lt-gt"><span class="nav-number">3.</span> <span class="nav-text">5. 泛型数组列表ArrayList&lt;&gt;()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-自动装箱与拆箱"><span class="nav-number">4.</span> <span class="nav-text">6.  自动装箱与拆箱</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-可变参数的方法"><span class="nav-number">5.</span> <span class="nav-text">7.可变参数的方法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#继承的设计技巧"><span class="nav-number"></span> <span class="nav-text">继承的设计技巧</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-接口、lambda"><span class="nav-number"></span> <span class="nav-text">4. 接口、lambda</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-接口"><span class="nav-number">1.</span> <span class="nav-text">1. 接口</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-1-接口静态方法"><span class="nav-number">1.1.</span> <span class="nav-text">1.1 接口静态方法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1-2-默认方法"><span class="nav-number">1.2.</span> <span class="nav-text">1.2 默认方法</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#接口与回调-callback"><span class="nav-number"></span> <span class="nav-text">接口与回调(callback)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#comparator接口-P224"><span class="nav-number"></span> <span class="nav-text">comparator接口(P224)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#对象克隆-Cloneable接口"><span class="nav-number"></span> <span class="nav-text">对象克隆 (Cloneable接口)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#渐析java的浅拷贝和深拷贝"><span class="nav-number"></span> <span class="nav-text">渐析java的浅拷贝和深拷贝</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-lambda"><span class="nav-number"></span> <span class="nav-text">2. lambda</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#函数式接口"><span class="nav-number"></span> <span class="nav-text">函数式接口</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#方法引用"><span class="nav-number"></span> <span class="nav-text">方法引用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#构造器引用"><span class="nav-number"></span> <span class="nav-text">构造器引用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#再谈lambda"><span class="nav-number"></span> <span class="nav-text">再谈lambda</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#常用函数式接口"><span class="nav-number"></span> <span class="nav-text">常用函数式接口</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#再谈-Comparator"><span class="nav-number"></span> <span class="nav-text">再谈 Comparator</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-内部类"><span class="nav-number"></span> <span class="nav-text">3.内部类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#双括号初始化"><span class="nav-number"></span> <span class="nav-text">双括号初始化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-代理"><span class="nav-number"></span> <span class="nav-text">4. 代理</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-泛型"><span class="nav-number"></span> <span class="nav-text">5. 泛型</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-泛型类"><span class="nav-number">1.</span> <span class="nav-text">1.泛型类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-泛型方法"><span class="nav-number">2.</span> <span class="nav-text">2.泛型方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-类型变量的限定"><span class="nav-number">3.</span> <span class="nav-text">3. 类型变量的限定</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-泛型代码和虚拟机"><span class="nav-number">4.</span> <span class="nav-text">4. 泛型代码和虚拟机</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-翻译泛型表达式和泛型方法"><span class="nav-number">5.</span> <span class="nav-text">5. 翻译泛型表达式和泛型方法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#桥方法"><span class="nav-number"></span> <span class="nav-text">桥方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#约束与局限性（P321）"><span class="nav-number"></span> <span class="nav-text">约束与局限性（P321）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#6-通配符类型"><span class="nav-number">1.</span> <span class="nav-text">6.通配符类型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-通配符捕获（P334）"><span class="nav-number">2.</span> <span class="nav-text">7. 通配符捕获（P334）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#8-反射和泛型"><span class="nav-number">3.</span> <span class="nav-text">8. 反射和泛型</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-集合"><span class="nav-number"></span> <span class="nav-text">6. 集合</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-集合框架图"><span class="nav-number"></span> <span class="nav-text">1. 集合框架图</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-总体分析："><span class="nav-number"></span> <span class="nav-text">2. 总体分析：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-Collection接口"><span class="nav-number"></span> <span class="nav-text">3. Collection接口</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-1-List接口"><span class="nav-number">1.</span> <span class="nav-text">3.1 List接口</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-Set接口"><span class="nav-number">2.</span> <span class="nav-text">3.2 Set接口</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-Map接口"><span class="nav-number"></span> <span class="nav-text">4. Map接口</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#4-1-HashMap"><span class="nav-number">1.</span> <span class="nav-text">4.1 HashMap</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-2-LinkedHashMap"><span class="nav-number">2.</span> <span class="nav-text">4.2 LinkedHashMap</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-3-TreeMap"><span class="nav-number">3.</span> <span class="nav-text">4.3 TreeMap</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-Iterator-与-ListIterator详解"><span class="nav-number"></span> <span class="nav-text">5. Iterator 与 ListIterator详解</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#5-1-Iterator"><span class="nav-number">1.</span> <span class="nav-text">5.1 Iterator</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-2-ListIterator"><span class="nav-number">2.</span> <span class="nav-text">5.2 ListIterator</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-异同点"><span class="nav-number"></span> <span class="nav-text">6. 异同点</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#6-1ArrayList和LinkedList"><span class="nav-number">1.</span> <span class="nav-text">6.1ArrayList和LinkedList</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-2-HashTable与HashMap"><span class="nav-number">2.</span> <span class="nav-text">6.2 HashTable与HashMap</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-3-HashMap、Hashtable、LinkedHashMap和TreeMap比较"><span class="nav-number">3.</span> <span class="nav-text">6.3 HashMap、Hashtable、LinkedHashMap和TreeMap比较</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-4-HashSet、LinkedHashSet、TreeSet比较"><span class="nav-number">4.</span> <span class="nav-text">6.4 HashSet、LinkedHashSet、TreeSet比较</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-5-Iterator和ListIterator区别"><span class="nav-number">5.</span> <span class="nav-text">6.5 Iterator和ListIterator区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-6-Collection-和-Collections区别"><span class="nav-number">6.</span> <span class="nav-text">6.6 Collection 和 Collections区别</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-多线程"><span class="nav-number"></span> <span class="nav-text">7. 多线程</span></a></li></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">shiysin</span>

  
</div>









<div class="busuanzi-count">
  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="site-uv">
      <i class="fa fa-user"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
    </span>
  
    <span class="site-pv">
      <i class="fa fa-eye"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
    </span>
    </div>
        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  
  

  

  

  

</body>
</html>
