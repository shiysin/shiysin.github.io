<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[MySQL基础知识]]></title>
    <url>%2F2019%2F09%2F07%2FMySQL%2F</url>
    <content type="text"><![CDATA[##1.操作数据表 ####1.MySQL登录 net start mysql80 or net stop mysql80 mysql -uroot -p password：1177 ####2.prompt 提示符 \D 当前日期 \d 当前数据库 \h 当前主机 \u 用户名 mysql -uroot -p --prompt \u@\h(\d)&gt; prompt \u@\h(\d)&gt; ####3.MySQL常用命令 SELECT VERSION()&nbsp;&nbsp;&nbsp;&nbsp;显示版本 SELECT NOW();&nbsp;&nbsp;显示日期 SELECT USER();&nbsp;&nbsp;显示用户 SELECT DATABASES()；&nbsp;&nbsp;显示数据库####4.创建数据库testCREATE DATABASE [IF NOT EXISTS]test [CHARACTER SET utf-8]; SHOW WARNINGS;&nbsp;&nbsp;//查看warning SHOW CREATE DATABASE test&nbsp;&nbsp;//展示创建的数据库信息####5.修改数据库编码 ALTER DATABASE test CHARACTER SET = utf-8####6.删除数据库 DROP DATABASE [IF EXISTS] test;####7.创建数据表及基本操作 CREATE TABLE test1( username VARCHAR(20) NOT NULL, //字段可以为空 age TINYINT UNSIGNED NULL, //非空 salary FLOAT(8,2) UNSIGNED ); 查看数据表列表 SHOW TABLES [FROM test] 查看数据表结构 SHOW COLUMNS FROM test; 插入记录 //若省略[]中内容，则所有字段都要赋值 INSERT test [username,age] VALUES(&apos;Cui&apos;,24); 查找记录 SELECT * FROM test; ####8.AUTO_INCREMENT &nbsp;自动编号 自动编号，必须与主键组合使用,但主键不必定需要AUTO_INCREMENT 默认情况下，起始值为1，每次的增量为1 不需要赋值 //必须设为主键 PRIMARY KEY CREATE TABLE test( id SMALLINT UNSIGNED AUTO_INCREMENT PRIMARY KEY, );####9.PRIMARY KEY 主键 主键约束 每张数据表只能存在一个主键 主键保证记录的唯一性 主键自动为NOT NULL CREATE TABLE test( id SMALL UNSIGNED PRIMARY KEY, );####10.UNIQUE KEY 唯一约束 唯一约束 唯一约束可以保证记录的唯一性 唯一约束的字段可以为空值(NULL) 每张数据表可以存在多个唯一约束&nbsp;(与主键的区别) CREATE TABLE test( id SMALLINT UNSIGNED AUTO_INCREMENT PRIMARY KEY, username VARCHAR(20) NOT NULL UNIQUE KEY, age TINYINT(3) UNSIGNED );####11.DEFAULT 默认约束 默认值 当插入记录时，如果没有明确为字段赋值，自动赋默认值 //sex字段没有赋值时，默认为3 CREATE TABLE test( id SMALLINT UNSIGNED AUTO_INCREMENT PRIMARY KEY, username VARCHAR(20) NOT NULL UNIQUE KEY, sex ENUM(&apos;1&apos;,&apos;2&apos;,&apos;3&apos;) DEFAULT &apos;3&apos; );##2.约束及修改数据表####1.约束 约束保证数据的一致性和完整性 约束分为表级约束和列级约束：对两个及以上字段使用为表级约束，对一个为列级约束 约束类型包括：NOT NULL(非空约束)、PRIMARY KEY (主键约束)、UNIQUE KEY(唯一约束)、DEFAULT (默认约束)、FOREIGN KEY(外键约束)####2.外键约束 保持数据的一致性、完整性&nbsp;&nbsp;&nbsp;&nbsp;因此称为 实现一对一或一对多关系&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;关系型数据库#####外键约束的要求: 父表和子表必须使用相同的存储引擎，且只能为InnoDB，禁止使用临时表 外键列和参照列必须具有相似的数据类型。数字的长度或有无符号位必须相同，字符长度可不同 外键列和参数列必须创建索引，如果外键列不存在索引，MySQL将自动创建索引。######创建一个省份数据表： CREATE TABLE provinces( id SMALLINT UNSIGNED PRIMARY KEY AUTO_INCREMENT, //参照列 pname VARCHAR(20) NOT NULL ); //查看存储引擎是否为InnoDB SHOW CREATE TABLE provinces;######创建一个用户数据表,存储用户所在省份： CREATE TABLE user( id SMALLINT UNSIGNED PRIMARY KEY AUTO_INCREMENT, //参照列 username VARCHAR(10) NOT NULL, pid SMALLINT UNSIGNED, //外键列 // FOREIGN KEY (pid) REFERENCES provinces (id) ); 显示索引： SHOW INDEXES FROM provinces\G;&nbsp;&nbsp;\G:以网格的形式呈现 ###3.外键约束的参照操作 CASCADE:从附表删除或更新时自动删除或更新子表中匹配的行 SET NULL:从父表删除或更新行，并设置子表中的外键列为NULL。使用该选项，必须保证子表列没有指定为NOT NULL。 RESTRICT:拒绝对父表的删除或更新操作。 NO ACTION:标准SQL的关键字，在MySQL中与RESTRICT相同。###4.修改数据表 添加单列 //FIRST|AFTER 控制添加列的位置 ALTER TABLE tbl_name ADD [COLUMN] col_name column_definition [FIRST|AFTER col_name] ALTER TABLE user ADD password VARCHAR(32) NOT NULL DEFAULT AFTER username; /插入在 username 列后 添加多列 ALTER TALBE tbl_name ADD [COLUMN]( col_name column_definition, ... ) 删除列 ALTER TABLE tbl_name DROP [COLUMN] col_name 删除多列且添加一列 ALTER TABLE tbl_name DROP col_name,DROP col_name,ADD col_name col_definition;###5.添加约束 添加主键约束 //CONSTRAINT 给主键添加名字 ALTER TABLE tbl_name ADD [CONSTRAINT[symbol]] PRIMARY KEY [index_type] (index_col_name,...) eg: ALTER TABLE user ADD CONSTRAINT user_id PRIMARY KEY (id); 添加唯一约束 ALTER TABLE tbl_name ADD [CONSTRAINT[symbol]] UNIQUE [INEX|KEY] [index_name] [index_type] (index_col_name,...) eg: ALTER TABLE user ADD UNIQUE (username); 添加外键约束 ALTER TABLE tbl_name ADD [CONSTRAINT[symbol]] FOREIGN KEY [index_type] (index_col_name,...) reference_definition eg: ALTER TABLE user ADD FOREIGN KEY (pid) REFERENCE provinces (id); 添加/删除默认约束 ALTER TABLE tbl_name ALTER [COLUMN] col_name {SET DEFAULT literal|DROP DEFAULT} eg: ALTER TABLE user ADD age TINYINT UNSIGNED NOT NULL; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ALTER TALBE user ALTER age SET DEFAULT 15;//添加默认约束 ALTER TABLE user ALTER age DROP DEFAULT;//删除默认约束 ###6.删除约束 删除主键约束 ALTER TABLE tbl_name DROP PRIMARY KEY 删除唯一约束 //一张表可以有多个唯一约束，因此删除需要唯一约束名字 ALTER TABLE tbl_name DROP {index|key} index_name eg: ALTER TABLE user DROP INDEX username; 删除外键约束 ALTER TABLE tbl_name DROP FOREIGN KEY fk_symbol eg: SHOW CREATE TABLE user;//查看外键约束的名字user_ibfk_1&nbsp;ALTER TABLE user FOREIGN KEY user_ibfk_1; 删除索引 eg:删除索引pid ALTER TABLE user DROP INDEX pid; ###7.修改列定义 ALTER TABLE tbl_name MODIFY [COLUMN] col_name col_definition [FIRST|AFTER col_name] eg: ALTER TABLE user MODIFY id SMALLINT UNSIGNED NOT NULL FIRST;//修改id字段为首列 类型同样可以修改，若由大类型改为小类型，可能会造成数据丢失 修改列名称 eg: ALTER TABLE user CHANGE pid p_id TINYINT UNSIGNED NOT NULL; //修改列名称pid为p_id ###8.修改数据表名称 方法1：ALTER TABLE tbl_name RENAME [TO|AS] new_tbl_name 方法2：RENAME TABLE tbl_name TO new_tbl_name [,tbl_name2 TO new_tbl_name2]…]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>DataBase</tag>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java核心技术一]]></title>
    <url>%2F2019%2F09%2F07%2FJava%2F</url>
    <content type="text"><![CDATA[1.数据类型1.1 整形 long类型后可加后缀&nbsp;”L”或”l”&nbsp;表示 二进制可加前缀&nbsp;”0b”或”0B”&nbsp;表示 八进制可加前缀&nbsp;”0”&nbsp;表示 十六进制可加前缀&nbsp;”0x”或”0X”表示 Java 7开始可为数字字面量加下划线使之更易读：1_000_000_000,编译器会去除 Java中没有任何无符号形式的整形 1.2 浮点类型 类型 存储需求 取值范围 float 4字节 大约3.402 823 47E+38F&nbsp;&nbsp;(有效位数为6~7位) double 8字节 大约1.797 693 134 862 315 70E+308 &nbsp;(有效位数为15位) double表示双精度，一般都采用double类型，除非需要单精度的库或需要存储大量数据 float类型后加后缀&nbsp;”F”或”f”&nbsp;表示；无后缀的默认为double类型 可用十六进制表示浮点数值，用p表示指数，而不是e 下面是表示溢出和出错情况的三个特殊的浮点数值&nbsp;(实际开发中很少用到)： Double.POSITIVE_INFINITY Double.NEGATIVE_INFINITY Double.NaN 正无穷大 负无穷大 NaN(不是一个数字) 可以使用Double.isNaN方法检查是不是一个数字 1.3char 类型 表示单个字符；也可以用一个或两个char表示Unicode字符 特殊字符的转义序列: 转义序列 名称 Unicode值 \b 退格 \u0008 \t 制表 \u0009 \n 换行 \u000a \r 回车 \u000d \‘’ 双引号 \u0022 \‘ 单引号 \u0027 \\ 反斜杠 \u005c Unicode转义序列会在解析代码之前得到处理 1.4 boolean类型 boolean类型有两个值：true、false 整形值和布尔值之间不能进行相互转换2. 变量 变量名必须是一个以字母开头 并由字母或数字构成的序列，字母包括Unicode字符 可以使用Character类的isJavaIdentifierStart和isJavaIdentifierPart方法来检查是否为Unicode字符2.1 常量 常量用关键字 final 表示，常量名全大写 final 表示这个变量只能被赋值一次，而后不能更改 类常量：可以在一个类的多个方法中使用，定义在main方法外部，可以使用关键字static final表示3. 运算符 整数被0除将会产生异常，浮点数被0除将会得到 无穷大 或 NaN 的结果3.1 Math数学函数与常量 sqrt(x)：平方根 pow(x, a):乘方 Math.PI: Math.e:e常量的近似值 floor: 返回不大于的最大整数 round: 表示“四舍五入”，算法为Math.floor(x+0.5)，即将原来的数字加上0.5后再向下取整。（正数小数点后大于5则进位；负数小数点后小于以及等于5都舍去，大于5的则进位） ceil: 不小于它的最小整数 floorMod 和 floorDiv 旨在解决整型余数问题。在java中，如果n为负数，n%2为-1，而floorMod(position + adjustment, 12)总是返回一个0到11之间的数字。（对于负的除数，还是会返回负值）。floorDiv则返回0到12之间的数字。 3.2 自增自减运算 前缀：先运算再使用数值 后缀：先使用数值再运算3.3 位运算符&amp;：and 与|：or 或^：xor 异或~：not 非&gt;&gt; 或 &lt;&lt;：位模式左移或右移&gt;&gt;&gt;:用0填充高位 3.4 运算符级别 运算符 结合性 [].()(方法调用) 从左向右 ! ~ ++ – + -(一元运算) ()(强制类型转换) new 从右向左 * / % 从左向右 + - 从左向右 &lt;&lt;&gt;&gt; &gt;&gt;&gt; 从左向右 &lt; &lt;= &gt; &gt;= instanceof 从左向右 == ！= 从左向右 &amp; 从左向右 ^ 从左向右 &#124; 从左向右 &amp;&amp; 从左向右 &#124;&#124; 从左向右 ? : 从右向左 = += -= *= /= %= &#124;= ^= &lt;&lt;= &gt;&gt;= &gt;&gt;&gt;= 从右向左 #### 4. 字符串 4.1 字符串 Java没有内置的字符串类型，而是在标准Java类库中提供了预定义类：String,且String为final不可变，因此总是线程安全的，一般都用它作为参数传递 substring(a, b)：截取字符串 + ：连接字符串 (每次连接，都会构建一个新的String对象，效率低占空间，使用StringBuilder类，通过apped添加字符串可避免此问题) join(“/“, “a”, “b”, “c”):分隔字符串 “a/b/c” equal:检测两个字符串是否相等“==”运算符只能检测两个字符串是否放在同一位置 equalIgnoreCase:忽略大小写检测是否相等 compareTo(String str)：按照字典顺序检测一个字符串是否在str前后位置，之前为负，之后为正，相等为0 replace(oldStr, newStr)：用newStr代替原始字符串中 所有的oldStr，并返回一个新字符串 toLowerCase() / toUpperCase()：更改大小写，并返回一个新串 trim()：删除原始字符串头部和尾部的空格 String类没有提供用于修改字符串的方法，如果想修改，可先substring截取需要的字符，再拼接替换的字符串不可变字符串的优点：编译器可以让字符串共享(复制原始字符串的效率远高于截取拼接，用StringBuilder可以高效拼接字符串) StringBuilder类中常用方法：StringBuilder append(String str):追加一个字符串并返回thisvoid setCharAt(int i, char c)：将第i个位置设为cStringBuilder insert(int offset, String str)：在offset位置插入一个字符串并返回thisStringBuilder delete(int startIndex, int endIndex)：删除偏移量从startIndex到-endIndex-1的字符并返回thistoString()：返回一个与构建器或缓冲器内容相同的字符串 4.2 空串 和 null 空串””：是长度为0的字符串。可用str.length()==0 或 str.equals(“”)检测 null：表示目前没有任何对象与该变量关联 检查一个字符串既不是null也不是空串：if(str != null &amp;&amp; str.length() != 0) 4.3 String / StringBuilder / StringBuffer 的区别执行速度快慢为：StringBuilder &gt; StringBuffer &gt; String ： 因为String为字符串常量，而StringBuilder和StringBuffer均为字符串变量，即String对象一旦创建之后该对象是不可更改的，但另外两者的对象是变量，是可以更改的。 在线程安全上，StringBuilder是线程不安全的，而StringBuffer是线程安全的，String为final不可变总是安全的： 如果一个StringBuffer对象在字符串缓冲区被多个线程使用时，StringBuffer中很多方法可以带有synchronized关键字，所以可以保证线程是安全的，但StringBuilder的方法则没有该关键字，所以不能保证线程安全，有可能会出现一些错误的操作。所以如果要进行的操作是多线程的，那么就要使用StringBuffer，但是在单线程的情况下，还是建议使用速度比较快的StringBuilder。 String：适用于少量的字符串操作的情况StringBuilder：适用于单线程下在字符缓冲区进行大量操作的情况StringBuffer：适用多线程下在字符缓冲区进行大量操作的情况 4.4 输入输出 Java SE 6 引入了Console类实现读取密码： Console cons = new Console(); String username = cons.realLine(&quot;username: &quot;); char[] passwd = cons.readPassword(&quot;Password: &quot;); //显示Password： 并读取输入 安全起见，返回的密码存放在一维字符数组中，而不是字符串中 (在对密码进行处理后，应该马上用一个填充值覆盖数组元素) 4.5 格式化输入 Java SE 5.0 引用了C库中的printf方法： 用于printf的转换符 转换符 类型 举例 d 十进制整数 77 x 十六进制整数 9f o 八进制整数 237 f 定点浮点数 15.7 e 指数浮点数 1.57e+01 g 通用浮点数 —— a 十六进制浮点数 0x1.fccdp3 s 字符串 Hello c 字符 H b 布尔 True h 散列码 42628b2 tx or Tx 日期时间 已过时，现用java.time类 % 百分号 % n 与平台有关的行分隔符 —— **用于printf的标志 标志 目的 举例 + 打印正数负数的符号 +333.33 空格 在正数之前添加空格 &#124; 333.33&#124; 0 数字前面补0 00333.33 - 左对齐 &#124;333.33 &#124; ( 将负数括在括号内 (333.33) , 添加分组分隔符 3,333,33 #(对于f格式) 包含小数点 3,333. #(对于x或0格式) 添加前缀0x或0 0xcafe $ 给定被格式化的参数索引:%1$x将以十六进制打印第一个参数 159 9F &lt; 格式化前面说明的数值:%d%&lt;x 以十进制和十六进制打印同一个数值 159 9F - 可以使用静态的String.format方法创建一个格式化的字符串，而不打印输出 ##### 4.6 文件输入与输出 - 读取文件：用File对象构造一个Scanner对象: in 12- **写入文件**：构造一个PrintWriter对象(如果文件不存在，创建该文件)： ```PrintWriter out = new PrintWriter(&quot;myfile.txt&quot;, &quot;UTF-8&quot;); PrintWriter(String fileName):构造一个将数据写入文件的PrintWriterstatic Path get(String pathName):根据给定的路径名构造一个Path 5. 控制流程 5.1 控制流程语句 Switch中，case标签可以是：类型为char、byte、short、int的常量表达式，枚举常量，字符串字面量(Java SE 7) 带标签的break：标签必须放在要跳出的最外层循环之前，且紧跟一个冒号”：”. 5.2 大数值BigInteger / BigDecimal java.math包中的两个类，可以处理包含任意长度数字序列的数值 使用BigInteger.valueOf方法可以将普通的数值转换为大数值:BigInteger a = new BigInteger.valueOf(100); 不能使用+/等处理大数值，而是使用 *add / multiply** 方法。 BigInteger add(BigInteger otherBigInteger subtract(BigInteger otherBigInteger multiply(BigInteger other)BIgInteger divide(BigInteger other)BigInteger mod(BigInteger other) 返回两个大整数的和、差、积、商、余数。int compareTo(BigInteger other) 两个大整数相等，返回0；小于返回负数，大于返回正数static BigInteger valueOf(long x) 返回值等于x的大整数static BigDecimal valueOf(long x, int scale) 返回值为x或 x / 10 ^ scale的一个大实数 5.3 数组 foreach循环 遍历数组中的每个元素 Arrays.toString(str)：打印一维数组中的所有值(更简单的遍历打印方法) Arrays.deepToString(str)：打印二维数组中的数据元素 匿名数组：new int[] {} 可以在不创建新变量的情况下重新初始化一个数组在返回值为数组的方法中，如果结果为0，则可以创建一个长度0的数组：new arrName[0]。数组长度为0与null不同。 Arrays.copyOf(str, str.length) ：将一个数组的所有值拷贝到一个新的数组中去，第二个参数是数组长度，通常用来增加数组的大小 5.4 命令行参数 public static void main(String[] args){}以java className -g cruel world 的形式运行程序：args数组将包含：args[0]： “-g”args[1]： “cruel”args[2]：”world” ***数组排序 随机不重复抽取一个范围内的数值：将数组最后一个值赋给之前抽取的数的索引，并将总数减去 1 ,则抽取不会重复 static int binarySearch(type[] a, int start, int end, type v)：采用二分搜索发查找值 static void fill(type[] a, type v)：将数组的所有数据元素设置为v static boolean equals(type[] a, type[] b)：如果两个数组大小相同，且下标相同的元素都对应相等，返回true 返回目录 2.对象与类三个主要特性： 对象的行为(behavior)：可以对对象施加哪些操作或方法 对象的状态(state)：施加方法时，对象如何响应 对象标识(identity)：如何辨别具有相同行为与状态的不同对象 一个对象变量并没有实际包含一个对象，而仅仅引用一个对象任何对象变量的值都是对存储在另外一个地方的一个对象的引用，new操作符的返回值也是一个引用 1. 类类之间的关系： 依赖(“uses-a”)：一个类的方法操作另一个类的对象 聚合(“has-a”)：类A 的对象包含 类B 的对象 继承(“is-a”)：类A 扩展 类B，继承 类B的方法1.1 更改器方法 与 访问器方法 更改器方法：调用后可以改变对象的状态 ，setter 访问器方法：只访问对象而不修改对象 ，getter 1.2 构造器 构造器总是伴随着new操作符的执行被调用，而不能对一个已经存在的对象调用构造器来达到重新设置实力域的目的 构造器与类同名 每个类可以有一个以上的构造器 构造器可以有0个、1个或多个参数 构造器没有返回值 所有Java的对象都是在堆中构造的 不要在构造器中定义与实例域重名的局部变量 1.3 隐式参数和显式参数 public void raiseSalary(double byPercent){ double raise = salary * byPercent / 100; //可以这样调用 double raise = this.salary * byPercent / 100; salary += raise; //this,salary += raise; } raiseSalary方法有两个参数，第一个为隐式参数，是在方法名之前的类对象，第二个为显式参数，位于方法名后面括号中。 隐式参数：方法调用的目标或接收者，this关键字表示隐式参数 显式参数：明显地列在方法声明中 1.4 封装的优点 通过 getName()、getAge()形式的方法获取实力域值，称为访问器方法 或 域访问器。 name是一个只读域，在构造器中设置完毕，就没有任何方法可以对它进行修改，这样确保name域不会受到外界的破坏 在需要获得或设置实力域的值时,应提供：一个私有的数据域一个公有的域访问器方法一个公有的域更改器方法 优点：可以改变内部实现，除了该类的方法之外，不会影响其他代码；更改器方法可以执行错误检查 注意：不要编写返回引用可变对象的访问器方法，否则会破坏封装性。 如果需要返回一个可变数据域的拷贝，就应该使用clone。 1.5 私有方法 在实现一个类时，所有数据域都应该设置为私有的，大部分方法都设计为公有的。公有方法不能随意删除，其他代码可能依赖于它。如果希望将一个计算代码划分成若干个独立的辅助方法，或者需要一个特别的协议以及一个特别的调用次序，可以将方法设为private的。(P111) 1.6 final实力域 可以将实力域定义为final，构建对象时必须初始化这样的域，且不可更改； final大都应用于基本类型域，或不可变类的域(类中每个方法都不会改变其对象,如String类) 1.7 静态域与静态方法 静态域：如果域定义为static，则一个类中只有一个这样的域； 静态方法：一种不能向对象实施操作的方法，或没有this的方法(在非静态方法中，this表示这个方法的隐式参数) 使用静态方法：一个方法不需要访问对象状态,其所需参数都是通过显式参数提供(如:Math.pow)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一个方法只需要访问类的静态域。 1.8 工厂方法静态方法还有另一常见用途，使用静态工厂方法来构造对象。如：NumberFormat类 NumberFormat currencyFormatter = NumberFormat.getCurrencyInstance(); NumberFormat percentFormat = NumberFormat.getPercentInstance(); double x = 0.1; syso.print(currencyFormatter.format(x)) //prints $0.10 syso.print(percentFormatter.fotmat(x)); //prints 10% 不使用构造器完成以上操作的原因：无法命名构造器，构造器的名字必须与类名相同，这里希望将得到的货币实力和百分比实例采用不同的名字。当使用构造器时，无法改变所构造的对象类型。而工厂方法将返回一个DecimalFormat类对象。 1.9 main方法 main方法不对任何对象进行操作，在启动程序时还没有任何一个对象，静态的main方法将执行并创建程序所需要的对象。 1.10 方法参数 按值调用：表示方法接收的是调用者提供的值。(Java采用按值调用，方法得到的是所有参数值的一个拷贝) 按引用调用：表示方法接收的是调用者提供的变量地址。 方法得到的是对象引用的拷贝，对象引用及其他的拷贝同时引用同一个对象(对象引用是按值传递的) Java中方法参数的使用情况：1.一个方法不能修改一个基本数据类型的参数(即数值型或布尔型) private int s = 0; public void changeParameter(int a) {a++;} public static void main(String[] args) { t.changeParameter(t.s); System.out.println(t.s); } 2.一个方法可以改变一个对象参数的状态3.一个方法不能让对象参数引用一个新的对象 2.对象构造2.1 重载 重载： 发生在同一个类中，方法名必须相同，参数类型不同、个数不同、顺序不同，方法返回值和访问修饰符可以不同，发生在编译时。 重写： 发生在父子类中，方法签名(方法名字和参数列表)必须相同，返回值范围小于等于父类，抛出的异常范围小于等于父类，访问修饰符范围大于等于父类；如果父类方法访问修饰符为 private 则子类就不能重写该方法。 2.2 默认域初始化 在构造器中没有显式地给域赋予初值，就会被自动地赋为默认值(数值为0，boolean为false，对象引用为null)，而方法中的局部变量必须明确地初始化。 2.3 参数名 一般在参数前面加个“a”， 或者 参数变量用相同的名字将实例域屏蔽，但可以采用 this隐式参数 来访问实例域 2.4 初始化块 初始化数据域的方法：在构造器中设置值， 或 在声明中赋值 或 初始化块：数据域在对象初始化块中被初始化，先运行初始化块，再运行构造器的主体.(通常直接将初始化块代码放入构造器) ``` { id = nextId; nextId++; ``` } 使用静态初始化块对静态域进行初始化 ... } 在类第一次加载时，将会初始化静态域 2.5 finalize方法 在垃圾回收器清除之前调用，回收资源，不要用来回收任何短缺资源，因为很难知道什么时候才能够调用。 确保finalizer方法在Java关闭前调用：使用Runtime.addShutdownHook添加“关闭钩”。 某个资源在使用完毕后要立刻关闭，可以使用close()方法 2.6 包 在两个包中有相同名称的类时，不能使用 * 来导入，可以在类名前面加上完整包名。 编译器在编译源文件时不检查目录结构 3。 注释 @param：变量描述 @return：描述 @throws：类描述 @author：姓名 @version：版本 @since：文本 @deprecated：文本，添加一个不再使用的注释 @see：引用，超链接 类的设计技巧1.保证数据私有2.对数据初始化3.不要在类中使用过多的基本类型4.不是所有的域都需要独立的域访问器和更改器5.将职责过多的类进行分解6.类名和方法名应体现它们的职责7.优先使用不可变的类 3.继承 一个对象变量可以指示多种实际类型的现象被称为 多态 在运行时能够自动地选择调用哪个方法的现象称为 动态绑定(默认的处理方式) 不允许扩展的类称为final类，不可被继承 强制转换：应先用if(Obj instanceof Obj)判断是否能够成功转换 只能在继承层次内进行类型转换 动态绑定的重要特性：无需对现存代码进行修改，就可以对程序进行扩展。理解方法调用： 1.编译器查看对象的声明类型和方法名。2.编译器查看调用方法时提供的参数类型。如果在所有名为上述的方法中存在一个与提供的参数类型完全匹配，就选择这个方法。此过程称为重载解析。3.如果是private、static、final方法或构造器，编译器将可以准确地知道应该调用哪个方法。这种调用方式为静态绑定。4.当程序运行，并且采用动态绑定调用方法时，虚拟机一定调用与x所引对象的实际类型最合适的那个类的方法。 调用e.getSalary()方法的解析过程： 1.虚拟机提取e的实际类型的放发表。既可能时Employee、Manager方法表，也可能时Employee类的其他子类的方法表。2.虚拟机搜索定义getSalary签名的类。此时虚拟机已经知道应该调用哪个方法。3.虚拟机调用方法。 #### 1.抽象类 abstract 1.包含一个或多个抽象方法的类必须为抽象的，但抽象类可以不包含抽象方法 2.抽象类可以包含具体的数据和方法，但不能被实例化 3.抽象类充当占位角色，具体实现 在子类中 4.扩展抽象类的两种方法：在抽象类中定义部分抽象方法或不定义抽象方法，则子类必须为抽象类；定义全部的抽象方法，则子类就不是抽象的 5.可以定义一个抽象类的对象变量，但只能引用非抽象子类的对象：Person p = new Student(); #### 2. == 和 equals **==** : 它的作用是判断两个对象的地址是不是相等。即，判断两个对象是不是同一个对象。(基本数据类型==比较的是值，引用数据类型==比较的是内存地址) equals() : 它的作用也是判断两个对象是否相等。但它一般有两种使用情况： 情况1：类没有覆盖 equals() 方法。则通过 equals() 比较该类的两个对象时，等价于通过“==”比较这两个对象。 情况2：类覆盖了 equals() 方法。一般，我们都覆盖 equals() 方法来两个对象的内容相等；若它们的内容相等，则返回 true (即，认为这两个对象相等)。 举个例子： java public class test1 { public static void main(String[] args) { String a = new String(&quot;ab&quot;); // a 为一个引用 String b = new String(&quot;ab&quot;); // b为另一个引用,对象的内容一样 String aa = &quot;ab&quot;; // 放在常量池中 String bb = &quot;ab&quot;; // 从常量池中查找 if (aa == bb) // true System.out.println(&quot;aa==bb&quot;); if (a == b) // false，非同一对象 System.out.println(&quot;a==b&quot;); if (a.equals(b)) // true System.out.println(&quot;aEQb&quot;); if (42 == 42.0) { // true System.out.println(&quot;true&quot;); }}}说明： String 中的 equals 方法是被重写过的，因为 object 的 equals 方法是比较的对象的内存地址，而 String 的 equals 方法比较的是对象的值。 当创建 String 类型的对象时，虚拟机会在常量池中查找有没有已经存在的值和要创建的值相同的对象，如果有就把它赋给当前引用。如果没有就在常量池中重新创建一个 String 对象。 3. hashCode 散列码是由对象导出的一个整型值，是没有规律的 hashCode方法定义在Object类中，因此每个对象都有一个默认的散列码，值为对象的存储地址。 StringBuilder类中没有定义hashCode方法，它的散列码是由Object类的默认hashCode方法导出的对象存储地址String类计算hashCode： int hash = 0; for(int i=0; i&lt;length(); i++){ hash = 31 * hash + charAt(i); } 字符串内容相同，则 散列码相同 int hashCode() ：返回对象的散列码 static int hash(Object…Objects) ：返回一个散列码，由提供的所有对象的散列码组合得到 static int hashCode((int|long|double|char|boolean…) value) ： 返回给定值的散列码 static int hashCode(type[] a) ： 计算数组a的散列码 4. toString 只要对象与一个字符串通过操作符“+”连接，Java编译就会自动地调用toString方法，以便获得这个对象的字符串描述。 强烈建议为自定义的每个类添加toString方法，便于从日志记录中获取信息和调试。 如下定义 public String toString(){ return getClass().getName()+&quot;[name=&quot; + name + &quot;,age=&quot; + age + &quot;]&quot;; }5. 泛型数组列表ArrayList&lt;&gt;() void ensureCapacity(int capacity)：确定数组存储元素数量后，分配包含capacity个内部数组 int size()：返回数组列表中包含的实际元素数目 void TrimToSize()：将数组列表的存储容量削减到当前尺寸(垃圾回收器回收多余的存储空间) 使用get、set实现访问或改变数组元素的操作set方法只能替换数组中已经存在的元素内容 灵活扩展数组并方便访问数组元素： ArrayList&lt;X&gt; list = new ArrayList&lt;&gt;(); while(...){ x = ...; list.add(x); } X[] a = new X[list.size()]; list.toArray(a); //在数组列表中间插入元素 int n = staff.size()/2; staff.add(n, e);6. 自动装箱与拆箱装箱：将基本类型用它们对应的引用类型包装起来； 拆箱：将包装类型转换为基本数据类型； 自动装箱规范要求boolean、byte、char &lt;= 127，介于-128~127之间的short和int被包装到固定的对象中。 由于包装器类引用可以为null，所有自动装箱有可能抛出NullPointerException异常。 装箱和拆箱是编译器认可的，而不是虚拟机 包含在包装器中的内容不会改变，可以用org.omg.CORBA包中的holder类型如IntHolder、BooleanHolder等来访问存储在其中的值： public static void triple(IntHolder x){ x.value = 3 * x.value; } static int parseInt(String s[, int radix])： 返回字符串s表示的整形数值(默认十进制)。或者radix规定的进制。 Static Integer valueOf(String s[, int radix])：返回用s表示的整形数值进行初始化后的一个新Integer对象。或者radix规定的进制。 Number parse(String s)：返回数字值，假设给定的String表示了一个数值。 7.可变参数的方法 max方法可以接收任意数量的参数，Object…与Object[]一样 public static double max(double...values){ double largest = Double.NEGATIVE_INFINITY; for(double v:values) if(v &gt; largest) largest = v; return largest; }main方法可以声明为下列形式：public static void main(String…args) 继承的设计技巧1.将公共操作和域放在超类；2.不要使用受保护的域；3.使用继承实现”is-a”关系；4.除非所有继承的方法都有意义，否则不要使用继承；5.再覆盖方法时，不要改变预期的行为；6.使用多态，而非类型信息；7.不要过多的使用反射。 返回目录 4. 接口、lambda接口 描述类具有什么功能 接口没有实例 实现接口的类必须实现接口中的所有方法 lambda 表示可以在将来某个时间点执行的代码块的简洁方法。可以用一种简洁的方式表示使用回调或变量行为的代码。 内部类 主要用于设计具有相互协作关系的类集合 代理 一种实现任意接口的对象。非常专业的构造工具，可以用来构建系统级的工具 1. 接口 接口中的所有方法自动地属于public； Java SE 8 之后，接口中可以提供简单的方法，且方法不能引用实例域； 提供实例域和方法实现的任务应该由实现接口的那个类来完成； 在实现接口时，必须把方法声明为public； 接口变量必须引用实现了接口的类对象； 可以使用instance检查一个对象是否实现了某个特定的接口； 接口中不能包含实例域或静态方法，却可以包含常量(Java SE 8可以有静态方法)； 接口中的域会自动被设为public static final 每个类只能继承一个类，却可以实现多个接口； 接口也可以被继承扩展(extends) 1.为什么必须用接口规定类：因为Java是强类型语言，在调用方法时，编译器会检查这个方法是否存在，当一个方法中有调用某个方法，则编译器必须确认这个方法一定存在，用接口来规定就表示一定有这个方法。 2.为什么有了抽象类还需要接口： 每个类只能继承一个类，却可以实现多个接口。 1.1 接口静态方法Java SE 8 中允许在接口中增加静态方法，但目前为止，都是将静态方法放在伴随类中。在标准库中有成对出现的接口和实用工具类，Collection/Collections或Path/Paths。（这个技术已经过时，现在可以直接在接口中实现方法。） 1.2 默认方法可以为接口提供一个默认实现，必须用 default 修饰。 public interface Comparable&lt;T&gt;{ default int compareTo(T other) {return 0;} } 为什么要默认方法：因为接口中的所有方法都要实现，若只需要其中一两个方法，则可以将方法都声明为default，需要时只需覆盖即可。 解决默认方法冲突： 如果在一个接口中将方法定义为默认方法，又在父类或另一个接口定义了同样的方法，则 父类优先接口冲突：父接口提供了一个默认方法，另一接口提供了同样的方法(不论是否是默认参数)，则必须覆盖这个方法来解决冲突。当一个类同时实现两个同样的接口时，需要程序员解决二义性。 接口与回调(callback)回调是一种常见的程序设计模式，可以指出某个特定事件发生时应该采取的动作。 public class TimerTest{ public static void main(String[] args){ ActionListener listener = new TimePrinter(); //构造TimePrinter类对象并转换为ActionListener Timer t = new Timer(10000, listener); //将ActionListener对象传给Timer类 t.start(); JOptionPane.showMessageDialog(null, &quot;Quit program?&quot;); //null表示在屏幕中央输出语句 System.exit(0); } } class TimerPrinter implements ActionListener{ public void actionPerformed(ActionEvent event){ //实现ActionListener接口中的方法 System.out.println(&quot;At the tone, the time is &quot; + new Date()); Toolkit.getDefaultToolkit().beep(); //发出铃响 } } comparator接口(P224)当需要按长度来比较时，可以使用一个数组和一个比较器作为参数，比较器是实现了Comparator接口的实例， public interface Comparator&lt;T&gt;{ int compare(T first, T second); }按长度比较字符串，可以定义如下实现Comparator的类： class LengthComparator implements Comparator&lt;String&gt;{ public int compare(String first, String second){ return first.length() - second.length(); } } 具体完成比较时，需要建立一个实例： Comparator&lt;String&gt; comp = new LengthComparator(); if(comp.compare(word[i], word[j]) &gt; 0)... 对象克隆 (Cloneable接口) Cloneable接口时Java提供的一组标记接口之一。通常用来确保一个类实现一个或一组特定的方法。标记接口不包含任何方法。它的唯一作用就是允许在类型查询中使用instanceof：(建议自己的程序中不要使用标记接口) if(Obj instanceof Cloneable)... Cloneable接口提供了一个安全的clone方法 (它没有指定clone方法，只是从Object类继承的) Clone方法是Object的一个protected方法，因此代码不能直接调用这个方法。它是个浅拷贝，当原对象与克隆对象的子对象是不可变时，它是安全的。但通常子对象都是可变的，则需要重新定义一个clone方法来建立深拷贝，同时克隆所有子对象。 对于每一个类，需要确定： 1，默认的clone方法是否满足要求；2.是否可以在可变的子对象上调用clone来修补默认的clone方法；3.是否不该使用clone。 实际上第3个是默认选项。如果选择1、2，类必须： 1.实现Cloneable接口；2.重新定义clone方法，并指定public访问修饰符。 对于Object类的protected clone方法，虽然所有类都是Object的子类，但子类只能调用protected clone方法来克隆它自己的对象，必须重新定义clone为public才能允许所有方法克隆对象。 深拷贝建立深拷贝，需要克隆对象中可变的实例域。 public Employee clone() throws CloneNotSupportedException{ Employee cloned = (Employee) super.clone(); cloned.hireDay = (Date) hireDay.clone(); //hireDay是一个Date，可变的 return cloned; }！！！ 所有数组类型都有一个public的clone方法，而不是protected。可以用这个方法建立一个新数组，包含原数组所有元素的副本。 返回目录 渐析java的浅拷贝和深拷贝浅拷贝：使用一个已知实例对新创建实例的成员变量逐个赋值，这个方式被称为浅拷贝。 深拷贝：当一个类的拷贝构造方法，不仅要复制对象的所有非引用成员变量值，还要为引用类型的成员变量创建新的实例，并且初始化为形式参数实例值。这个方式称为深拷贝 也就是说浅拷贝只复制一个对象，传递引用，不能复制实例。而深拷贝对对象内部的引用均复制，它是创建一个新的实例，并且复制实例。 对于浅拷贝当对象的成员变量是基本数据类型时，两个对象的成员变量已有存储空间，赋值运算传递值，所以浅拷贝能够复制实例。但是当对象的成员变量是引用数据类型时，就不能实现对象的复制了。 存在一个对象Person，代码如下： public class Asian { private String skin; Person person; public Asian(String skin,Person person){ this.skin = skin; this.person = person; //引用赋值 } public Asian(Asian asian){ //拷贝构造方法，复制对象 this(asian.skin,asian.person); } } 上面的对象Person有三个成员变量。name、sex、age。两个构造方法。第二个的参数为该对象，它称为拷贝构造方法，它将创建的新对象初始化为形式参数的实例值，通过它可以实现对象复制功能。 又有一个对象Asian,如下： public class Asian { private String skin; Person person; public Asian(String skin,Person person){ this.skin = skin; this.person = person; //引用赋值 } public Asian(Asian asian){ //拷贝构造方法，复制对象 this(asian.skin,asian.person); } }上面对象也存在着两个成员变量，skin 和Person对象 对于person对象有如下： Person p1 = new Person(&quot;李四&quot;,&quot;mam&quot;,23); Person p2 = new Person(P1); 当调用上面的语句时。P2对象将会对P1进行复制。执行情况如下如下图： Asian a1 = new Asian(&quot;yellow&quot;,new Person(&quot;李四&quot;,&quot;mam&quot;,23)); Asian a2 = new Asian(a1);对于Asian对象有： New Asian(a1)执行Asian类的拷贝构造方法，由于对象赋值是引用赋值。使得a1和a2引用同一个对象 如下图： 当a1执行某条可以改变该值的语句时，那么a1将会通过这个语句也可以改变a2对象的成员变量 如果执行以下语句： 2. lambda lambda是一个可传递的代码块，可以在以后执行一个或多次。 带参数变量的表达式称为lambda表达式。 即使lambda表达式没有参数，仍然要提供空括号(),就像无参方法一样; 如果可以推导出一个lambda表达式的参数，则可以忽略其类型： Comparator&lt;String&gt; comp = (first, second) -&gt; first.length() - second.length(); //因为这个lambda将赋给一个字符串比较器 如果方法只有一个参数，而且这个参数的类型可以推导出，甚至可以省略小括号： ActionListener listener = event -&gt; System.out.println(&quot;...&quot;); 无需指定lambda的返回类型，会由上下文推导得出： (String first, String second) -&gt; first.length() - second.length() //可以在需要int类型结果的上下文中使用 如果一个lambda表达式只在某些分支返回一个值，而在另外一些分支不返回值，这是不合法的。 (int x) -&gt; {if(x &gt;= 0) return 1;} 修改ActionListener接口： Timer t = new Timer(10000, event -&gt; System.out.println(&quot;...&quot;)); 函数式接口 对于只有一个抽象方法的接口，需要这个接口的对象时，就可以提供一个lambda表达式。称为函数式接口。 如：Comparator接口 Arrays.sort(words, (first, second) -&gt; first.length() - second.length()); //Arrays.sort的第二个参数需要一个Comparator实例 ！！！！！！！ 在Java中，对lambda表达式能做的也只是能转换成函数式接口 不能把lambda赋给类型为Object的变量，Object不是一个函数式接口 方法引用Timer t = new Timer(10000, System.out::println); System.out::println是一个方法引用，等价于lambda表达式 x -&gt; System.out.println(x); 如果想不考虑大小写来对字符串排序： Arrays.sort(strings, String::compareToIgnoreCase)方法引用有3种情况： object :: instanceMethod Class :: staticMethod Class :: instanceMethod 1和2等价于lambda表达式，类似于Math::pow等价于 (x, y) -&gt; Math.pow(x, y)对于3，第一个参数会成为方法的目标。如：String::compareTOIgnoreCase等价于(x, y) -&gt; x.compareToIgnoreCase(y) 类似于lambda表达式，方法引用不能独立存在，总是会转换为函数式接口的实例。 可以在方法引用里使用this。如：this::equals 等同于 x -&gt; this.equals(x) 使用super也是合法的 super::instanceMethod 使用this作为目标，会调用给定方法的父类版本： class Greeter{ public void greet(){ System.out.println(&quot;Hello&quot;); } } class TimedGreeter extends Greeter{ public void greet(){ Timer t = new Timer(1000, super::greet); //执行super::greet方法时，会调用父类的greet方法 t.start(); } }构造器引用 与方法引用类似，不过方法名为new。如：Person::new是Person构造器的一个引用 可以用数组类型建立构造器引用。如：int[]::new，它有一个参数 数组长度。等价于lambda的 x -&gt; new int[x] Java有一个限制，无法构造泛型类型数组，数组构造器引用可以克制这个限制。如：new T[n]会产生错误，因为会改为 new Object[n]假设需要一个Person对象数组。Stream接口有一个toArray方法可以返回Object数组：Object[] people = stream.toArray();不过需要的是Person引用数组，而不是Object引用数组，可以这样做：Person[] people = stream.toArray(Person[]::new);toArray方法调用这个构造器来得到一个正确类型的数组。 再谈lambdalambda表达式有3个部分： 1.一个代码块2.参数3.自由变量的值，这是指非参数而且不在代码中定义的变量。 关于代码块及自由变量有一个术语：闭包(closure)。在Java中，lambda表达式就是闭包。 lambda表达式可以捕获外围作用域中变量的值，不过要确保捕获的值是明确定义的。 lambda表达式中，只能引用值不会改变的变量。若在lambda中引用变量，而变量可能在外部改变，也是不合法的。即：lambda中捕获的变量必须是最终变量 在lambda中声明与一个局部变量同名的参数或局部变量是不合法的。 在lambda中使用this关键字，是指创建这个lambda表达式的方法的this参数。 使用lambda表达式的重点是 延迟执行，之所以要延迟执行，有： 1. 在一个单独的线程中运行代码。 2. 多次运行代码。 3. 在算法的适当位置运行代码。(如排序的比较操作) 4. 发生某种情况时执行代码。(如点击了一个按钮，数据到达等) 5. 只在必要时才运行代码。 常用函数式接口 函数式接口 参数类型 返回类型 抽象方法名 描述 其他方法 Runnable 无 void run 作为无参数或返回值的动作运行 Supplier 无 T get 提供一个T类型的值 Consumer T void accept 处理一个T类型的值 andThen BiConsumer&lt;T,U&gt; T, U void accept 处理T和U类型的值 andThen Function&lt;T, R&gt; T R apply 有一个T类型参数的函数 compose,andThen,identity BiFunction&lt;T,U,R&gt; T,U R apply 有T和U类型参数的函数 andThen UnaryOperator T T apply 类型T上的一元操作符 compose,andThen,identity BinaryOperator T,T T apply 类型T上的二元操作符 andThen,maxBy,minBy Predicate T boolean test 布尔值函数 and,or,negate,isEqual BiPredicate&lt;T,U&gt; T,U boolean test 有两个参数的布尔值函数 and,or,negate ### 基本类型的函数式接口 函数式接口 参数类型 返回类型 抽象方法名 BooleanSupplier none boolean getAsBoolean PSupplier none p getAsP PConsumer p void accept OjbPConsumer&lt;T T,p void accept PFunction&lt;T p T apply PToQFunction p q applyAsQ ToPFunction&lt;T T p applyAsP ToPBiFunction&lt;T,U&gt; T,U p applyAsP PUnaryOperator p p applyAsP PBinaryOperator p,p p applyAsP PPredicate p boolean test 注：p,q为int,long,double; P,Q为Int,Long,Double. 如果设计自己的接口，其中只有一个抽象方法，可以用@FunctionInterface注解来标记这个接口。 返回目录 再谈 Comparator…… 3.内部类 内部类方法可以访问该类定义所在的作用域中的数据，包括私有的数据。也可以访问创建它的外围类对象的数据域及私有数据。 内部类可以对同一个包中的其他类隐藏。 内部类中声明的所有静态域都必须是final。因为一个静态域只有一个实例，而每个外部对象都分别有一个单独的内部类实例。如果不是final，就可能不是唯一的。 内部类不能有static方法， 当想要定义一个回调函数且不想编写大量代码时，使用匿名内部类比较便捷。 只有内部类可以是私有类，常规类只可以是protected或public。可以使用 outerObject.new InnerClass(construction parameters) 语法格式更加明确地编写内部对象的构造器。this通常可以省去。内部类对象的外围类引用被设置为创建内部类对象的方法中的this引用。 可以显式地命名将外围类引用设置为其他的对象。如：TimePrinter是个公有内部类，对于任意的语音时钟都可以构造一个TimePrinter： TalkintClock jabberer = new TalkingClock(1000, true); TalkingClock.TimePrinter listener = jabberer.new TimePrinter();需要注意，在外围类的作用域之外，可以用OuterClass.InnerClass这样引用内部类。 内部类是一种编译器现象，与虚拟器无关。编译器会把内部类翻译成用$分隔外部类名与内部类名的常规类文件，而虚拟机对此一无所知。 3.1. 局部内部类： 局部内部类不能用public或private访问说明符进行声明，它的作用域被限定在声明这个局部类的块中。 局部类对外部世界完全地绝对隐藏起来 局部类不仅能够访问包含它们地外部类，还可以访问局部变量。但局部变量必须是final，即一旦赋值绝不会改变。假设想更新在一个封闭作用域内地计时器，这时final限制则不太方便。可以使用一个长度为1地数组： counter++; //错误 counter[0]++; //长度为1的数组 3.2. 匿名内部类 如果只创建类的一个对象，则可以不用命名。 匿名类没有构造器，而会将构造器参数传递给父类构造器。在实现接口时，不能有任何参数。 public void start(int interval, boolean beep){ ActionListener listener = new ActionListener(){ public void actionPerformed(ActionEvent event){ System.out.println(&quot;&quot; + new Date()); if(beep) Toolkit.getDefaultToolkit().beep(); } }}; Timer t = new Timer(interval, listener); t.start(); } 一般Java程序员用匿名内部类实现事件监听器和其他回调。 双括号初始化 如果只需要传递一个数组到一个方法，之后不再需要，则可以使用匿名内部类语法： invite(new ArrayList&lt;String&gt;(){{add("Tom");add("Tony")}});外层括号建立了ArrayList的一个匿名子类，内层括号则是一个对象构造块。 生成日志或调试消息时，通常希望包含当前类名。通过 getClass() 来实现，不过getClass调用的时this.getClass()，而静态方法没有this。所以应该使用以下表达式： new Object(){}.getClass().getEnclosingClass() new Object(){}会建立Object的一个匿名子类的一个匿名对象，getEnclosingClass则得到其外围类，也就是包含这个静态方法的类。 3.3. 静态内部类 解决类名冲突：将类定义为另一个类的 内部公有类，可以通过 OuterClass.InnerClass访问它。如果使用内部类只是为了把一个类隐藏在另外一个类的内部，不需要内部类引用外围类对象时，则可以将内部类声明为static，以便取消产生的引用。 只有内部类可以声明为static 静态内部类可以有静态域和方法。 4. 代理 代理可以在运行时创建全新的类，这样的代理能够实现指定的接口。且具有下列方法： 指定接口所需要的全部方法。 Object类中的全部方法，如 toString、equals等。 然而不能再运行时定义这些方法的新代码，而是要提供一个调用处理器，调用处理器是实现了InvocationHandler接口的类对象。在这个接口中只有一个方法：Object invoke(Object proxy, Method method, Object[] args) ,无论何时调用代理对象的方法，调用处理器的invoke方法都会被调用，并向其传递Method对象和原始的调用参数。调用处理器必须给出处理调用的方式。 创建代理，需要使用Proxy类的newProxyInstance方法,此方法有三个参数 ： 一个类加载器，null表示默认的加载器 一个Class对象数组，每个元素都是需要实现的接口。 一个调用处理器。 返回目录 5. 泛型 类型参数的好处：使得程序具有更好的可读性和安全性。 设计泛型类型的目的：允许泛型代码和遗留代码之间能够互操作。 1.泛型类定义泛型类Pair： public class Pair&lt;T&gt;{ priavte T first,second; public Pair() {first = null; second = null;} public Pair(T first, T second) {this.first = first; this.second = second;} public T getFirst() {return first;} public T getSecond() {return second;} public void setFirst(T newValue) {first = newValue;} public void setSecond(T newValue) {second = newValue;} } 一个泛型类(generic class)就是具有一个或多个类型变量的类。 类型变量一般使用大写形式，且比较短。 泛型类可看作普通类的工厂。用具体的类型替换类型变量就可以实例化泛型类型，如Pair，可以将结果想象成带有构造器的普通类和访问器及更改器方法。 2.泛型方法定义泛型方法： public static &lt;T&gt; T getMiddle(T...a){ //类型变量放在修饰符后，返回类型前。第二个T为返回类型 return a[a.length / 2]; } 泛型方法可以定义在普通类或泛型类中 如果想知道编译器对一个泛型方法调用最终推断出哪种类型：有目的地引入一个错误，并研究所产生的错误消息。 3. 类型变量的限定&lt;T extends Comparable&gt; //表示为实现了Comparable接口地类 为什么使用extends而不是implements？ 表示T应该是绑定类型的子类型。T和绑定类型可以是类，也可以是接口。 一个类型变量或通配符可以有多个限定：T extends Comparable &amp; Serializable 限定类型用“&amp;”分隔，逗号用来分隔类型变量。 可以根据需要拥有多个接口父类型，但限定中至多有一个类。如果用一个类作为限定，它必须是限定列表中的第一个。 4. 泛型代码和虚拟机虚拟机没有泛型类型对象，在编译阶段会擦除类型变量，并用第一个限定的类型变量替换 (无限定的变量用Object)。Pair的原始类型如： public class Pair{ priavte Object first, second; public Pair(Object first, Object second){ this.first = first; this.second = second; } ... } 为了提高效率，标签接口（如：Serializable）应放在边界列表的末尾。 5. 翻译泛型表达式和泛型方法程序调用泛型方法时，如果擦出返回类型，编译器会插入Employee的强制类型转换，会把这个方法调用翻译为两条虚拟机指令： Pair&lt;Employee&gt; buddies = ...; Employee buddy = buddies.getFirst(); 对原始方法Pair.getFirst的调用。 将返回的Object类型强制转换为Employee类型。 泛型方法也进行类型擦除： public static &lt;T extends Comparable&gt; T min(T[] a) 擦除后： public static Comparable min(Comparable[] a) 桥方法Class DateInterval extends Pair&lt;LocalDate&gt;{ public void setSecond(LocalDate second){ if(second.compareTo(getFirst()) &gt;= 0) super.setSecond(second); } }类型擦除后： class DateInterval extends Pair{ public void setSecond(LocalDate second) {...} ... }方法的擦除会使得存在另一个方法，即 public void setSecond(Object second)此方法的类型参数为Object，而不是LocalDate。 DateInterval interval = new DateInterval(...); Pair&lt;LocalDate&gt; pair = interval; pair.setSecond(aDate); 这里希望对setSecond的调用具有多态性，并调用最合适的那个方法。由于pair引用DateInterval对象，所以应该调用DateInterval.setSecond。但是类型擦除与多态发生了冲突，此时需要编译器在DateInterval类中生成一个桥方法(bridge method)： //setSecond((Date) second)为强制类型转换，使其调用的是DateInterval.setSecond(Date)方法 public void setSecond (Object second) { setSecond((Date) second); } 变量pair已经声明为类型Pair，并且这个类型只有一个简单的方法setSecond(Object)，虚拟机用pair引用的对象调用这个方法。 这个对象时DateInterval类型的，因而将会调用DateInterval.setSecond(Object)方法，这个方法是合成的桥方法。它调用DateInterval.setSecond(Date)。 Java泛型转换： 虚拟机中没有泛型，只有普通的类和方法。 所有的类型参数都用它们的限定类型替换。 桥方法被合成用来保持多态。 为保持类型安全性，必要时插入强制类型转换。 Java 泛型详解 10 道 Java 泛型面试题 约束与局限性（P321） 不能用基本类型实例化类型参数 运行时类型查询instanceof只适用于原始类型 不能创建参数化类型的数组，如 Pair[] table = new Pair[10]; //Error。但声明可以 Varargs警告：向参数个数可变的方法传递一个泛型类型的实例。添加注解@SuppressWarnings(“unchecked”)或@SafeVarargs标注 不能实例化类型变量，如 public Pair() {first = new T();} //Error。类型擦出后T会改为Object 不能构造泛型数组 不能在静态域或方法中引用类型变量 不能抛出或捕获泛型类的实例，也不能扩展Throwable。但在异常规范中使用类型变量是允许的:public static void doWork(T t) throws T 可以消除对受查异常的检查。Java异常处理原则：必须为所有受查异常提供一个处理器。可以利用泛型消除这个限制 注意擦除后的冲突。泛型规范原则：要想支持擦出的转换，就需要强行限制一个类或类型变量不能同时成为两个接口类型的子类，而这两个接口是同一接口的不同参数化。 6.通配符类型通配符类型中，允许类型参数变化。如： public static void printBuddies(Pair&lt;? extends Employee&gt; p)类型Pair是Pair&lt;? extends Employee&gt;的子类型。 Pair&lt;manager&gt; managerBuddies = new Pair(ceo, cfo); Pair&lt;? extends Employee&gt; wildcardBuddies = managerBuddies; //OK wildcardBuddies.setFirst(lowlyEmployee); //complile-time error对setFirst的调用有一个类型错误。类型Pair&lt;? extends Employee&gt;方法应是这样： ? extends Employee getFirst() void setFirst(? extends Employee)这样不可能调用setFirst方法。编译器只知道需要某个Employee的子类型，但不知道具体是什么类型。因此它拒绝传递任何特定的类型。但是getFirst就不存在此问题：将getFirst的返回值赋给一个Employee的引用完全合法。这样可以区分 安全的访问器方法 和 不安全的更改器方法。 通配符的超类型限定：? super Manager限制为Manager的所有超类型。带有超类型限定的通配符可以向泛型对象写入，带有子类型限定的通配符可以从泛型对象读取 无限定通配符Pair&lt;?&gt;，有以下方法： ? getFirst() void setFirst(?) getFirst的返回值只能赋给一个Object。setFirst方法不能被调用，甚至不能用Object调用。 Pair&lt;?&gt;和Pair的本质不同在于：可以用任意Object对象调用原始Pair类的setObjecgt方法。 可以调用 setFirst(null) 7. 通配符捕获（P334） 通配符捕获只有在有许多限制的情况下才是合法的。 编译器必须能够确信通配符表达的是单个、确定的类型。 8. 反射和泛型对象是泛型类的实例时，泛型类参数会被擦除，得不到太多信息。通过反射可以获得泛型类的信息。 使用Class参数进行类型匹配。 返回目录 6. 集合1. 集合框架图 简化图： 说明：对于以上的框架图有如下几点说明： 1.所有集合类都位于java.util包下。Java的集合类主要由两个接口派生而出：Collection和Map，Collection和Map是Java集合框架的根接口，这两个接口又包含了一些子接口或实现类。 集合接口：6个接口（短虚线表示），表示不同集合类型，是集合框架的基础。 抽象类：5个抽象类（长虚线表示），对集合接口的部分实现。可扩展为自定义集合类。 实现类：8个实现类（实线表示），对接口的具体实现。 Collection 接口是一组允许重复的对象。 Set 接口继承 Collection，集合元素不重复。 List 接口继承 Collection，允许重复，维护元素插入顺序。 Map接口是键－值对象，与Collection接口没有什么关系。 Set、List和Map可以看做集合的三大类： List集合是有序集合，集合中的元素可以重复，访问集合中的元素可以根据元素的索引来访问。 Set集合是无序集合，集合中的元素不可重复，访问集合中的元素只能根据元素本身来访问（也是集合里元素不允许重复的原因）。 Map集合中保存Key-value对形式的元素，访问时只能根据每项元素的key来访问其value。 2. 总体分析： 大致说明：看上面的框架图，先抓住它的主干，即Collection和Map。 1、Collection是一个接口，是高度抽象出来的集合，它包含了集合的基本操作和属性。Collection包含了List和Set两大分支。 （1）List是一个有序的队列，每一个元素都有它的索引。第一个元素的索引值是0。List的实现类有LinkedList, ArrayList, Vector, Stack。 （2）Set是一个不允许有重复元素的集合。Set的实现类有HastSet和TreeSet。HashSet依赖于HashMap，它实际上是通过HashMap实现的；TreeSet依赖于TreeMap，它实际上是通过TreeMap实现的。 2、Map是一个映射接口，即key-value键值对。Map中的每一个元素包含“一个key”和“key对应的value”。AbstractMap是个抽象类，它实现了Map接口中的大部分API。而HashMap，TreeMap，WeakHashMap都是继承于AbstractMap。Hashtable虽然继承于Dictionary，但它实现了Map接口。 3、接下来，再看Iterator。它是遍历集合的工具，即我们通常通过Iterator迭代器来遍历集合。我们说Collection依赖于Iterator，是因为Collection的实现类都要实现iterator()函数，返回一个Iterator对象。**ListIterator是专门为遍历List而存在的。** 4、再看Enumeration，它是JDK 1.0引入的抽象类。作用和Iterator一样，也是遍历集合；但是Enumeration的功能要比Iterator少。在上面的框图中，Enumeration只能在Hashtable, Vector, Stack中使用。 5、最后，看Arrays和Collections。它们是操作数组、集合的两个工具类。 有了上面的整体框架之后，我们接下来对每个类分别进行分析。 3. Collection接口Collection接口是处理对象集合的根接口，其中定义了很多对元素进行操作的方法。Collection接口有两个主要的子接口List和Set，注意Map不是Collection的子接口，这个要牢记。 Collection接口中的方法如下: 其中，有几个比较常用的方法，比如方法add()添加一个元素到集合中，addAll()将指定集合中的所有元素添加到集合中，contains()方法检测集合中是否包含指定的元素，toArray()方法返回一个表示集合的数组。 另外，Collection中有一个iterator()函数，它的作用是返回一个Iterator接口。通常，我们通过Iterator迭代器来遍历集合。ListIterator是List接口所特有的，在List接口中，通过ListIterator()返回一个ListIterator对象。 Collection接口有两个常用的子接口，下面详细介绍。 3.1 List接口List集合代表一个有序集合，集合中每个元素都有其对应的顺序索引。List集合允许使用重复元素，可以通过索引来访问指定位置的集合元素。 List接口继承于Collection接口，它可以定义一个允许重复的有序集合。因为List中的元素是有序的，所以我们可以通过使用索引（元素在List中的位置，类似于数组下标）来访问List中的元素，这类似于Java的数组。 List接口为Collection直接接口。List所代表的是有序的Collection，即它用某种特定的插入顺序来维护元素顺序。用户可以对列表中每个元素的插入位置进行精确地控制，同时可以根据元素的整数索引（在列表中的位置）访问元素，并搜索列表中的元素。实现List接口的集合主要有：ArrayList、LinkedList、Vector、Stack。 （1）ArrayListArrayList是一个动态数组，也是我们最常用的集合。它允许任何符合规则的元素插入甚至包括null。每一个ArrayList都有一个初始容量（10），该容量代表了数组的大小。随着容器中的元素不断增加，容器的大小也会随着增加。在每次向容器中增加元素的同时都会进行容量检查，当快溢出时，就会进行扩容操作。所以如果我们明确所插入元素的多少，最好指定一个初始容量值，避免过多的进行扩容操作而浪费时间、效率。 size、isEmpty、get、set、iterator 和 listIterator 操作都以固定时间运行。add 操作以分摊的固定时间运行，也就是说，添加 n 个元素需要 O(n) 时间（由于要考虑到扩容，所以这不只是添加元素会带来分摊固定时间开销那样简单）。 ArrayList擅长于随机访问。同时ArrayList是非同步的。 （2）LinkedList同样实现List接口的LinkedList与ArrayList不同，ArrayList是一个动态数组，而LinkedList是一个双向链表。所以它除了有ArrayList的基本操作方法外还额外提供了get，remove，insert方法在LinkedList的首部或尾部。 由于实现的方式不同，LinkedList不能随机访问，它所有的操作都是要按照双重链表的需要执行。在列表中索引的操作将从开头或结尾遍历列表（从靠近指定索引的一端）。这样做的好处就是可以通过较低的代价在List中进行插入和删除操作。 与ArrayList一样，LinkedList也是非同步的。如果多个线程同时访问一个List，则必须自己实现访问同步。一种解决方法是在创建List时构造一个同步的List： List list = Collections.synchronizedList(new LinkedList(…)); （3）Vector与ArrayList相似，但是Vector是同步的。所以说Vector是线程安全的动态数组。它的操作与ArrayList几乎一样。 （4）StackStack继承自Vector，实现一个后进先出的堆栈。Stack提供5个额外的方法使得Vector得以被当作堆栈使用。基本的push和pop 方法，还有peek方法得到栈顶的元素，empty方法测试堆栈是否为空，search方法检测一个元素在堆栈中的位置。Stack刚创建后是空栈。 3.2 Set接口 Set是一种不包括重复元素的Collection。它维持它自己的内部排序，所以随机访问没有任何意义。与List一样，它同样允许null的存在但是仅有一个。由于Set接口的特殊性， 所有传入Set集合中的元素都必须不同，同时要注意任何可变对象，如果在对集合中元素进行操作时，导致e1.equals(e2)==true，则必定会产生某些问题。Set接口有三个具体实现类，分别是散列集HashSet、链式散列集LinkedHashSet和树形集TreeSet。 Set是一种不包含重复的元素的Collection，无序，即任意的两个元素e1和e2都有e1.equals(e2)=false，Set最多有一个null元素。需要注意的是:虽然Set中元素没有顺序，但是元素在set中的位置是由该元素的HashCode决定的，其具体位置其实是固定的。 此外需要说明一点，在set接口中的不重复是有特殊要求的。 举一个例子:对象A和对象B，本来是不同的两个对象，正常情况下它们是能够放入到Set里面的，但是如果对象A和B的都重写了hashcode和equals方法，并且重写后的hashcode和equals方法是相同的话。那么A和B是不能同时放入到Set集合中去的，也就是Set集合中的去重和hashcode与equals方法直接相关。 为了更好地理解，请看下面的例子： public class Test{ public static void main(String[] args) { Set&lt;String&gt; set=new HashSet&lt;String&gt;(); set.add(&quot;Hello&quot;); set.add(&quot;world&quot;); set.add(&quot;Hello&quot;); System.out.println(&quot;集合的尺寸为:&quot;+set.size()); System.out.println(&quot;集合中的元素为:&quot;+set.toString()); } }运行结果： 集合的尺寸为:2集合中的元素为:[world, Hello] 分析：由于String类中重写了hashcode和equals方法，用来比较指向的字符串对象所存储的字符串是否相等。所以这里的第二个Hello是加不进去的。 再看一个例子： public class TestSet { public static void main(String[] args){ Set&lt;String&gt; books = new HashSet&lt;String&gt;(); //添加一个字符串对象 books.add(new String(&quot;Struts2权威指南&quot;)); //再次添加一个字符串对象， //因为两个字符串对象通过equals方法比较相等，所以添加失败，返回false boolean result = books.add(new String(&quot;Struts2权威指南&quot;)); System.out.println(result); //下面输出看到集合只有一个元素 System.out.println(books); } }运行结果： false[Struts2权威指南] 说明：程序中，book集合两次添加的字符串对象明显不是一个对象（程序通过new关键字来创建字符串对象），当使用==运算符判断返回false，使用equals方法比较返回true，所以不能添加到Set集合中，最后只能输出一个元素。 （1）HashSet HashSet 是一个没有重复元素的集合。它是由HashMap实现的，不保证元素的顺序(这里所说的没有顺序是指：元素插入的顺序与输出的顺序不一致)，而且HashSet允许使用null 元素。HashSet是非同步的，如果多个线程同时访问一个哈希set，而其中至少一个线程修改了该set，那么它必须保持外部同步。** HashSet按Hash算法来存储集合的元素，因此具有很好的存取和查找性能。** HashSet的实现方式大致如下，通过一个HashMap存储元素，元素是存放在HashMap的Key中，而Value统一使用一个Object对象。 HashSet使用和理解中容易出现的误区: a. HashSet中存放null值HashSet中是允许存入null值的，但是在HashSet中仅仅能够存入一个null值。 b.HashSet中存储元素的位置是固定的HashSet中存储的元素的是无序的，这个没什么好说的，但是由于HashSet底层是基于Hash算法实现的，使用了hashcode，所以HashSet中相应的元素的位置是固定的。 c.必须小心操作可变对象（Mutable Object）。如果一个Set中的可变元素改变了自身状态导致Object.equals(Object)=true将导致一些问题。 （2）LinkedHashSet LinkedHashSet继承自HashSet，其底层是基于LinkedHashMap来实现的，有序，非同步。LinkedHashSet集合同样是根据元素的hashCode值来决定元素的存储位置，但是它同时使用链表维护元素的次序。这样使得元素看起来像是以插入顺序保存的，也就是说，当遍历该集合时候，LinkedHashSet将会以元素的添加顺序访问集合的元素。 （3）TreeSetTreeSet是一个有序集合，其底层是基于TreeMap实现的，非线程安全。TreeSet可以确保集合元素处于排序状态。TreeSet支持两种排序方式，自然排序和定制排序，其中自然排序为默认的排序方式。当我们构造TreeSet时，若使用不带参数的构造函数，则TreeSet的使用自然比较器；若用户需要使用自定义的比较器，则需要使用带比较器的参数。 注意：TreeSet集合不是通过hashcode和equals函数来比较元素的.它是通过compare或者comparaeTo函数来判断元素是否相等.compare函数通过判断两个对象的id，相同的id判断为重复元素，不会被加入到集合中。 4. Map接口 Map与List、Set接口不同，它是由一系列键值对组成的集合，提供了key到Value的映射。同时它也没有继承Collection。 在Map中它保证了key与value之间的一一对应关系。也就是说一个key对应一个value，所以它不能存在相同的key值，当然value值可以相同。 4.1 HashMap 以哈希表数据结构实现，查找对象时通过哈希函数计算其位置，它是为快速查询而设计的，其内部定义了一个hash表数组（Entry[] table），元素会通过哈希转换函数将元素的哈希地址转换成数组中存放的索引，如果有冲突，则使用散列链表的形式将所有相同哈希地址的元素串起来，可能通过查看HashMap.Entry的源码它是一个单链表结构。 4.2 LinkedHashMap LinkedHashMap是HashMap的一个子类，它保留插入的顺序，如果需要输出的顺序和输入时的相同，那么就选用LinkedHashMap。 LinkedHashMap是Map接口的哈希表和链接列表实现，具有可预知的迭代顺序。此实现提供所有可选的映射操作，并允许使用null值和null键。此类不保证映射的顺序，特别是它不保证该顺序恒久不变。 LinkedHashMap实现与HashMap的不同之处在于，后者维护着一个运行于所有条目的双重链接列表。此链接列表定义了迭代顺序，该迭代顺序可以是插入顺序或者是访问顺序。 根据链表中元素的顺序可以分为：按插入顺序的链表，和按访问顺序(调用get方法)的链表。默认是按插入顺序排序，如果指定按访问顺序排序，那么调用get方法后，会将这次访问的元素移至链表尾部，不断访问可以形成按访问顺序排序的链表。 注意，此实现不是同步的。如果多个线程同时访问链接的哈希映射，而其中至少一个线程从结构上修改了该映射，则它必须保持外部同步。 由于LinkedHashMap需要维护元素的插入顺序，因此性能略低于HashMap的性能，但在迭代访问Map里的全部元素时将有很好的性能，因为它以链表来维护内部顺序。 4.3 TreeMap TreeMap 是一个有序的key-value集合，非同步，基于红黑树（Red-Black tree）实现，每一个key-value节点作为红黑树的一个节点。TreeMap存储时会进行排序的，会根据key来对key-value键值对进行排序，其中排序方式也是分为两种，一种是自然排序，一种是定制排序，具体取决于使用的构造方法。 自然排序：TreeMap中所有的key必须实现Comparable接口，并且所有的key都应该是同一个类的对象，否则会报ClassCastException异常。 定制排序：定义TreeMap时，创建一个comparator对象，该对象对所有的treeMap中所有的key值进行排序，采用定制排序的时候不需要TreeMap中所有的key必须实现Comparable接口。 TreeMap判断两个元素相等的标准：两个key通过compareTo()方法返回0，则认为这两个key相等。 如果使用自定义的类来作为TreeMap中的key值，且想让TreeMap能够良好的工作，则必须重写自定义类中的equals()方法，TreeMap中判断相等的标准是：两个key通过equals()方法返回为true，并且通过compareTo()方法比较应该返回为0。 返回目录 5. Iterator 与 ListIterator详解5.1 IteratorIterator的定义如下： public interface Iterator&lt;E&gt; {} Iterator是一个接口，它是集合的迭代器。集合可以通过Iterator去遍历集合中的元素。Iterator提供的API接口如下： boolean hasNext()：判断集合里是否存在下一个元素。如果有，hasNext()方法返回 true。 Object next()：返回集合里下一个元素。 void remove()：删除集合里上一次next方法返回的元素。 使用示例： public class IteratorExample { public static void main(String[] args) { ArrayList&lt;String&gt; a = new ArrayList&lt;String&gt;(); a.add(&quot;aaa&quot;); a.add(&quot;bbb&quot;); a.add(&quot;ccc&quot;); System.out.println(&quot;Before iterate : &quot; + a); Iterator&lt;String&gt; it = a.iterator(); while (it.hasNext()) { String t = it.next(); if (&quot;bbb&quot;.equals(t)) { it.remove(); } } System.out.println(&quot;After iterate : &quot; + a); } }输出结果如下： Before iterate : [aaa, bbb, ccc] After iterate : [aaa, ccc] 注意： （1）Iterator只能单向移动。 （2）Iterator.remove()是唯一安全的方式来在迭代过程中修改集合；如果在迭代过程中以任何其它的方式修改了基本集合将会产生未知的行为。而且每调用一次next()方法，remove()方法只能被调用一次，如果违反这个规则将抛出一个异常。 5.2 ListIterator ListIterator是一个功能更加强大的迭代器, 它继承于Iterator接口,只能用于各种List类型的访问。可以通过调用listIterator()方法产生一个指向List开始处的ListIterator, 还可以调用listIterator(n)方法创建一个一开始就指向列表索引为n的元素处的ListIterator. ListIterator接口定义如下: public interface ListIterator&lt;E&gt; extends Iterator&lt;E&gt; { boolean hasNext(); E next(); boolean hasPrevious(); E previous(); int nextIndex(); int previousIndex(); void remove(); void set(E e); void add(E e); }由以上定义我们可以推出ListIterator可以: (1)双向移动（向前/向后遍历）. (2)产生相对于迭代器在列表中指向的当前位置的前一个和后一个元素的索引. (3)可以使用set()方法替换它访问过的最后一个元素. (4)可以使用add()方法在next()方法返回的元素之前或previous()方法返回的元素之后插入一个元素. 使用示例： public class ListIteratorExample { public static void main(String[] args) { ArrayList&lt;String&gt; a = new ArrayList&lt;String&gt;(); a.add(&quot;aaa&quot;); a.add(&quot;bbb&quot;); a.add(&quot;ccc&quot;); System.out.println(&quot;Before iterate : &quot; + a); ListIterator&lt;String&gt; it = a.listIterator(); while (it.hasNext()) { System.out.println(it.next() + &quot;, &quot; + it.previousIndex() + &quot;, &quot; + it.nextIndex()); } while (it.hasPrevious()) { System.out.print(it.previous() + &quot; &quot;); } System.out.println(); it = a.listIterator(1); while (it.hasNext()) { String t = it.next(); System.out.println(t); if (&quot;ccc&quot;.equals(t)) { it.set(&quot;nnn&quot;); } else { it.add(&quot;kkk&quot;); } } System.out.println(&quot;After iterate : &quot; + a); } }输出结果如下： Before iterate : [aaa, bbb, ccc] aaa, 0, 1 bbb, 1, 2 ccc, 2, 3 ccc bbb aaa bbb ccc After iterate : [aaa, bbb, kkk, nnn]6. 异同点6.1ArrayList和LinkedList （1）ArrayList是实现了基于动态数组的数据结构，LinkedList基于链表的数据结构。 （2）对于随机访问get和set，ArrayList绝对优于LinkedList，因为LinkedList要移动指针。 （3）对于新增和删除操作add和remove，LinedList比较占优势，因为ArrayList要移动数据。 这一点要看实际情况的。若只对单条数据插入或删除，ArrayList的速度反而优于LinkedList。但若是批量随机的插入删除数据，LinkedList的速度大大优于ArrayList。因为ArrayList每插入一条数据，要移动插入点及之后的所有数据。 6.2 HashTable与HashMap相同点： （1）都实现了Map、Cloneable、java.io.Serializable接口。 （2）都是存储”键值对(key-value)”的散列表，而且都是采用拉链法实现的。 不同点： （1）历史原因:HashTable是基于陈旧的Dictionary类的，HashMap是Java 1.2引进的Map接口的一个实现 。 （2）同步性:HashTable是线程安全的，也就是说是同步的，而HashMap是线程序不安全的，不是同步的 。 （3）对null值的处理：HashMap的key、value都可为null，HashTable的key、value都不可为null 。 （4）基类不同：HashMap继承于AbstractMap，而Hashtable继承于Dictionary。 Dictionary是一个抽象类，它直接继承于Object类，没有实现任何接口。Dictionary类是JDK 1.0的引入的。 虽然Dictionary也支持“添加key-value键值对”、“获取value”、“获取大小”等基本操作，但它的API函数比Map少；而且Dictionary一般是通过Enumeration(枚举类)去遍历，Map则是通过Iterator(迭代M器)去遍历。 然而由于Hashtable也实现了Map接口，所以，它即支持Enumeration遍历，也支持Iterator遍历。 AbstractMap是一个抽象类，它实现了Map接口的绝大部分API函数；为Map的具体实现类提供了极大的便利。它是JDK 1.2新增的类。 （5）支持的遍历种类不同：HashMap只支持Iterator(迭代器)遍历。而Hashtable支持Iterator(迭代器)和Enumeration(枚举器)两种方式遍历。 6.3 HashMap、Hashtable、LinkedHashMap和TreeMap比较 Hashmap 是一个最常用的Map，它根据键的HashCode 值存储数据，根据键可以直接获取它的值，具有很快的访问速度。遍历时，取得数据的顺序是完全随机的。HashMap最多只允许一条记录的键为Null;允许多条记录的值为Null;HashMap不支持线程的同步，即任一时刻可以有多个线程同时写HashMap;可能会导致数据的不一致。如果需要同步，可以用Collections的synchronizedMap方法使HashMap具有同步的能力。 Hashtable 与 HashMap类似，不同的是:它不允许记录的键或者值为空;它支持线程的同步，即任一时刻只有一个线程能写Hashtable，因此也导致了Hashtale在写入时会比较慢。 LinkedHashMap保存了记录的插入顺序，在用Iterator遍历LinkedHashMap时，先得到的记录肯定是先插入的，也可以在构造时用带参数，按照应用次数排序。在遍历的时候会比HashMap慢，不过有种情况例外，当HashMap容量很大，实际数据较少时，遍历起来可能会比LinkedHashMap慢，因为LinkedHashMap的遍历速度只和实际数据有关，和容量无关，而HashMap的遍历速度和他的容量有关。如果需要输出的顺序和输入的相同，那么用LinkedHashMap可以实现，它还可以按读取顺序来排列，像连接池中可以应用。 LinkedHashMap实现与HashMap的不同之处在于，后者维护着一个运行于所有条目的双重链表。此链接列表定义了迭代顺序，该迭代顺序可以是插入顺序或者是访问顺序。对于LinkedHashMap而言，它继承与HashMap、底层使用哈希表与双向链表来保存所有元素。其基本操作与父类HashMap相似，它通过重写父类相关的方法，来实现自己的链接列表特性。 TreeMap实现SortMap接口，内部实现是红黑树。能够把它保存的记录根据键排序，默认是按键值的**升序排序，也可以指定排序的比较器，当用Iterator 遍历TreeMap时，得到的记录是排过序的。TreeMap不允许key的值为null。非同步的。** 一般情况下，我们用的最多的是HashMap，HashMap里面存入的键值对在取出的时候是随机的，它根据键的HashCode值存储数据，根据键可以直接获取它的值，具有很快的访问速度。在Map 中插入、删除和定位元素，HashMap 是最好的选择。TreeMap取出来的是排序后的键值对。但如果要按自然顺序或自定义顺序遍历键，那么TreeMap会更好。LinkedHashMap 是HashMap的一个子类，如果需要输出的顺序和输入的相同，那么用LinkedHashMap可以实现，它还可以按读取顺序来排列，像连接池中可以应用。 import java.util.HashMap; import java.util.Iterator; import java.util.LinkedHashMap; import java.util.TreeMap; public class MapTest { public static void main(String[] args) { //HashMap HashMap&lt;String,String&gt; hashMap = new HashMap(); hashMap.put(&quot;4&quot;, &quot;d&quot;); hashMap.put(&quot;3&quot;, &quot;c&quot;); hashMap.put(&quot;2&quot;, &quot;b&quot;); hashMap.put(&quot;1&quot;, &quot;a&quot;); Iterator&lt;String&gt; iteratorHashMap = hashMap.keySet().iterator(); System.out.println(&quot;HashMap--&gt;&quot;); while (iteratorHashMap.hasNext()){ Object key1 = iteratorHashMap.next(); System.out.println(key1 + &quot;--&quot; + hashMap.get(key1)); } //LinkedHashMap LinkedHashMap&lt;String,String&gt; linkedHashMap = new LinkedHashMap(); linkedHashMap.put(&quot;4&quot;, &quot;d&quot;); linkedHashMap.put(&quot;3&quot;, &quot;c&quot;); linkedHashMap.put(&quot;2&quot;, &quot;b&quot;); linkedHashMap.put(&quot;1&quot;, &quot;a&quot;); Iterator&lt;String&gt; iteratorLinkedHashMap = linkedHashMap.keySet().iterator(); System.out.println(&quot;LinkedHashMap--&gt;&quot;); while (iteratorLinkedHashMap.hasNext()){ Object key2 = iteratorLinkedHashMap.next(); System.out.println(key2 + &quot;--&quot; + linkedHashMap.get(key2)); } //TreeMap TreeMap&lt;String,String&gt; treeMap = new TreeMap(); treeMap.put(&quot;4&quot;, &quot;d&quot;); treeMap.put(&quot;3&quot;, &quot;c&quot;); treeMap.put(&quot;2&quot;, &quot;b&quot;); treeMap.put(&quot;1&quot;, &quot;a&quot;); Iterator&lt;String&gt; iteratorTreeMap = treeMap.keySet().iterator(); System.out.println(&quot;TreeMap--&gt;&quot;); while (iteratorTreeMap.hasNext()){ Object key3 = iteratorTreeMap.next(); System.out.println(key3 + &quot;--&quot; + treeMap.get(key3)); } } }输出结果为： HashMap–&gt; 3–c 2–b 1–a 4–d LinkedHashMap–&gt; 4–d 3–c 2–b 1–a TreeMap–&gt; 1–a 2–b 3–c 4–d 6.4 HashSet、LinkedHashSet、TreeSet比较 Set接口Set不允许包含相同的元素，如果试图把两个相同元素加入同一个集合中，add方法返回false。Set判断两个对象相同不是使用==运算符，而是根据equals方法。也就是说，只要两个对象用equals方法比较返回true，Set就不会接受这两个对象。 HashSetHashSet有以下特点： 不能保证元素的排列顺序，顺序有可能发生变化。 不是同步的。 集合元素可以是null，但只能放入一个null。 当向HashSet结合中存入一个元素时，HashSet会调用该对象的hashCode()方法来得到该对象的hashCode值，然后根据 hashCode值来决定该对象在HashSet中存储位置。 简单的说，HashSet集合判断两个元素相等的标准是两个对象通过equals方法比较相等，并且两个对象的hashCode()方法返回值也相等。 注意，如果要把一个对象放入HashSet中，重写该对象对应类的equals方法，也应该重写其hashCode()方法。其规则是如果两个对象通过equals方法比较返回true时，其hashCode也应该相同。 另外，对象中用作equals比较标准的属性，都应该用来计算 hashCode的值。 LinkedHashSet LinkedHashSet集合同样是根据元素的hashCode值来决定元素的存储位置，但是它同时使用链表维护元素的次序。这样使得元素看起来像是以插入顺序保存的，也就是说，当遍历该集合时候，LinkedHashSet将会以元素的添加顺序访问集合的元素。 LinkedHashSet在迭代访问Set中的全部元素时，性能比HashSet好，但是插入时性能稍微逊色于HashSet。 TreeSet类 TreeSet是SortedSet接口的唯一实现类，TreeSet可以确保集合元素处于排序状态。 TreeSet支持两种排序方式，自然排序和定制排序，其中自然排序为默认的排序方式。向TreeSet中加入的应该是同一个类的对象。 TreeSet判断两个对象不相等的方式是两个对象通过equals方法返回false，或者通过CompareTo方法比较没有返回0。 自然排序 自然排序使用要排序元素的CompareTo（Object obj）方法来比较元素之间大小关系，然后将元素按照升序排列。 Java提供了一个Comparable接口，该接口里定义了一个compareTo(Object obj)方法，该方法返回一个整数值，实现了该接口的对象就可以比较大小。obj1.compareTo(obj2)方法如果返回0，则说明被比较的两个对象相等，如果返回一个正数，则表明obj1大于obj2，如果是负数，则表明obj1小于obj2。如果我们将两个对象的equals方法总是返回true，则这两个对象的compareTo方法返回应该返回0。 定制排序 自然排序是根据集合元素的大小，以升序排列，如果要定制排序，应该使用Comparator接口，实现 int compare(T o1,T o2)方法。 package com.test; import java.util.HashSet; import java.util.LinkedHashSet; import java.util.TreeSet; /** * @description 几个set的比较 * HashSet：哈希表是通过使用称为散列法的机制来存储信息的，元素并没有以某种特定顺序来存放； * LinkedHashSet：以元素插入的顺序来维护集合的链接表，允许以插入的顺序在集合中迭代； * TreeSet：提供一个使用树结构存储Set接口的实现，对象以升序顺序存储，访问和遍历的时间很快。 * @author Zhou-Jingxian * */ public class SetDemo { public static void main(String[] args) { HashSet&lt;String&gt; hs = new HashSet&lt;String&gt;(); hs.add(&quot;B&quot;); hs.add(&quot;A&quot;); hs.add(&quot;D&quot;); hs.add(&quot;E&quot;); hs.add(&quot;C&quot;); hs.add(&quot;F&quot;); System.out.println(&quot;HashSet 顺序:\n&quot;+hs); LinkedHashSet&lt;String&gt; lhs = new LinkedHashSet&lt;String&gt;(); lhs.add(&quot;B&quot;); lhs.add(&quot;A&quot;); lhs.add(&quot;D&quot;); lhs.add(&quot;E&quot;); lhs.add(&quot;C&quot;); lhs.add(&quot;F&quot;); System.out.println(&quot;LinkedHashSet 顺序:\n&quot;+lhs); TreeSet&lt;String&gt; ts = new TreeSet&lt;String&gt;(); ts.add(&quot;B&quot;); ts.add(&quot;A&quot;); ts.add(&quot;D&quot;); ts.add(&quot;E&quot;); ts.add(&quot;C&quot;); ts.add(&quot;F&quot;); System.out.println(&quot;TreeSet 顺序:\n&quot;+ts); } }输出结果： HashSet 顺序:[D, E, F, A, B, C] LinkedHashSet 顺序:[B, A, D, E, C, F] TreeSet 顺序:[A, B, C, D, E, F] 6.5 Iterator和ListIterator区别 我们在使用List，Set的时候，为了实现对其数据的遍历，我们经常使用到了Iterator(迭代器)。使用迭代器，不需要干涉其遍历的过程，只需要每次取出一个想要的数据进行处理就可以了。但是在使用的时候也是有不同的。 List和Set都有iterator()来取得其迭代器。对List来说，也可以通过listIterator()取得其迭代器，两种迭代器在有些时候是不能通用的，Iterator和ListIterator主要区别在以下方面： （1）ListIterator有add()方法，可以向List中添加对象，而Iterator不能 （2）ListIterator和Iterator都有hasNext()和next()方法，可以实现顺序向后遍历，但是ListIterator有hasPrevious()和previous()方法，可以实现逆向（顺序向前）遍历。Iterator就不可以。 （3）ListIterator可以定位当前的索引位置，nextIndex()和previousIndex()可以实现。Iterator没有此功能。 （4）都可实现删除对象，但是ListIterator可以实现对象的修改，set()方法可以实现。Iierator仅能遍历，不能修改。因为ListIterator的这些功能，可以实现对LinkedList等List数据结构的操作。其实，数组对象也可以用迭代器来实现。 6.6 Collection 和 Collections区别 （1）java.util.Collection 是一个集合接口（集合类的一个顶级接口）。它提供了对集合对象进行基本操作的通用接口方法。Collection接口在Java 类库中有很多具体的实现。Collection接口的意义是为各种具体的集合提供了最大化的统一操作方式，其直接继承接口有List与Set。 Collection ├List │├LinkedList │├ArrayList │└Vector │ └Stack └Set （2）java.util.Collections 是一个包装类（工具类/帮助类）。它包含有各种有关集合操作的静态多态方法。此类不能实例化，就像一个工具类，用于对集合中元素进行排序、搜索以及线程安全等各种操作，服务于Java的Collection框架。代码示例： import java.util.ArrayList; import java.util.Collections; import java.util.List; public class TestCollections { public static void main(String args[]) { //注意List是实现Collection接口的 List list = new ArrayList(); double array[] = { 112, 111, 23, 456, 231 }; for (int i = 0; i &lt; array.length; i++) { list.add(new Double(array[i])); } Collections.sort(list); for (int i = 0; i &lt; array.length; i++) { System.out.println(list.get(i)); } // 结果：23.0 111.0 112.0 231.0 456.0 } } 返回目录 7. 多线程 Java多线程学习（总结很详细！！！） Java中的多线程你只要看这一篇就够了]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring基础知识]]></title>
    <url>%2F2019%2F09%2F07%2Fspring%2F</url>
    <content type="text"><![CDATA[1. spring的注入方式a . bean配置 设值注入 setXxx()方法， 构造注入 标签 p命名空间 xmlns:p=”http://www.springframework.org/schema/p&quot; 并在标签中 P:name=”” 自动装配 (只适用于引用类型)autowire=”byName | byType | constructor | no” （不建议多次使用） 在&lt; bean id=”” autowire=”byName” /&gt; ,当id的类中有和IOC容器中bean的id相同时，自动装配byName : bean的id值=类的属性名byType : 其他bean的类型（class）是否与该类的ref属性类型一致(当前IOC容器中只能有一个bean满足条件)constructor : 其他bean的类型（class）是否与该类的构造方法参数的类型一致，本质是byType 在头文件的beans标签中添加统一自动装配：default-autowire=”byName” 自动装配虽然可以减少代码量，但是会降低程度的可读性，使用时需要谨慎 b . 注解方式 @Component细化： @Repository Dao层 @Service service层 @Controller controller层 配置包扫描器： xmlns:context=&quot;http://www.springframework.org/schema/context&quot; http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd &lt;context:component-scan base-package=&quot;com.test.pojo&quot; /&gt; 在声明前加上 @Value(“”) 2. 使用注解实现声明式事务1.需要的包： spring-tx.jar ojdbc.jar 驱动 commons-dbcp.jar 连接池使用到的数据源 commons-pool.jar 连接池 spring-jdbc.jar aopalliance.jar aop相关 2.增加事务tx的命名空间 3.增加对事务的支持(核心)： &lt;tx:annotation-driven transaction-manager=&quot;txManager&quot; /&gt; 配置事务管理器： &lt;bean id=&quot;txManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt; &lt;/bean&gt; 配置数据库相关： &lt;bean id=&quot;dataSource&quot; class=&quot;org.apache.commons.dbcp2.BasicDataSource&quot;&gt; &lt;property name=&quot;driverClassName&quot; value=&quot;oracle.jdbc.OracleDriver&quot; /&gt; &lt;property name=&quot;url&quot; value=&quot;&quot; /&gt; &lt;property name=&quot;username&quot; value=&quot;system&quot; /&gt; &lt;property name=&quot;password&quot; value=&quot;123456&quot; /&gt; &lt;property name=&quot;maxIdle&quot; value=&quot;10&quot; /&gt; &lt;property name=&quot;maxWaitMillis&quot; value=&quot;1000&quot; /&gt; &lt;/bean&gt;4.将需要成为事务的方法 前增加注解： @Transactional(readOnly=false,propagation=Propagation.REQUIRED,rollBackFor=...)3. AOP需要的jar: aopliance.jar aspectjweaver.jar 通知类型：org.springframework.aop. 前置通知：MethodBeforeAdvice 接口方法 before() 后置通知：AfterReturningAdvice 接口方法 afterReturning() 异常通知：ThrowsAdvice 接口方法 无 环绕通知：MethodInterceptor 接口方法 invoke() &lt;!-- 配置前置通知 切面 --&gt; &lt;bean id=&quot;logBefore&quot; class=&quot;com.test.aop.LogBefore&quot;&gt; &lt;/bean&gt; &lt;!-- 关联切入点和切面 --&gt; &lt;aop:config &gt; &lt;!-- 配置切入点 --&gt; &lt;aop:pointcut id=&quot;pointcut&quot; expression=&quot;execution(public void com.test.service.demoService.DemoServiceImpl.addUser())&quot; /&gt; &lt;!-- 连接线 --&gt; &lt;aop:advisor advice-ref=&quot;logBefore&quot; pointcut-ref=&quot;pointcut&quot; /&gt; &lt;/aop:config&gt; 异常通知必须实现方法： public void afterThrowing(Throwable ex) or public void afterThrowing(Method method, Object[] args, Object target, Throwable ex)环绕通知： @Override public Object invoke(MethodInvocation mi) throws Throwable { Object result = null; try { System.out.println(&quot;环绕-前置通知&quot;); //在此之前的为前置通知 result = mi.proceed(); //控制目标方法是否执行 //在此之后的为后置通知 System.out.println(&quot;环绕-后置通知:目标对象:&quot; + mi.getThis() + &quot;,调用的方法:&quot; + mi.getMethod().getName() + &quot;,参数个数:&quot; + mi.getArguments().length + &quot;,返回值:&quot; + result); }catch (Exception e){ //异常通知 System.out.println(&quot;环绕-异常通知&quot;); } return result; }注解实现AOP 前置: @Before 后置: @AfterReturning 异常: @AfterThrowing 环绕: @Around 最终: @After 注解形式AOP，需设置扫描器，扫描器会将指定的包中的 @Component @Service @Repository @Controller修饰的类产生的对象增加到IOC容器 通过注解形式实现的AOP，若要获取目标对象的一些参数，则需要使用一个对象：JoinPoint @Component(“logAnnotation”) @Aspect //表示此类是一个AOP通知 public class LogAnnotation { // 前置通知 @Before(&quot;execution(public void addUser())&quot;) // 属性定义触发时机(切点) public void myBefore(JoinPoint jp){ System.out.println(&quot;《注解》-前置通知:目标对象:&quot; + jp.getTarget() + &quot;,方法名:&quot; + jp.getSignature().getName() + &quot;,参数个数:&quot; +jp.getArgs().length ); } // 后置通知 @AfterReturning(pointcut = &quot;execution(public void deleteUser())&quot;, returning = &quot;returningValue&quot;) // 属性定义触发时机(切点) public void myAfter(JoinPoint jp, Object returningValue){ //需要声明该方法有返回值, returningValue 是返回值 System.out.println(&quot;《注解》-后置通知:目标对象:&quot; + jp.getTarget() + &quot;,方法名:&quot; + jp.getSignature().getName() + &quot;,参数列表:&quot; + Arrays.toString(jp.getArgs()) + &quot;,返回值:&quot; + returningValue ); } // 异常通知：如果只捕获特定类型的异常，则可以通过第二个参数实现：e @AfterThrowing(pointcut = &quot;execution(public void addUser())&quot;, throwing = &quot;e&quot;) public void myException(JoinPoint jp, NullPointerException e){ System.out.println(&quot;《注解》-异常通知: &quot; + e.getMessage()); } // 环绕通知 @Around(&quot;execution(public void addUser())&quot;) public void myAround(ProceedingJoinPoint pjp){ //前置通知 System.out.println(&quot;《注解-环绕》-前置通知&quot;); try{ pjp.proceed(); // 执行方法,抛出的是Throwable System.out.println(&quot;《注解-环绕》-后置通知&quot;); }catch (Throwable e){ // 异常通知 System.out.println(&quot;《注解-环绕》-异常通知&quot;); }finally { // 最终通知 System.out.println(&quot;《注解-环绕》-最终通知&quot;); } } //单独的最终通知 @After(&quot;execution(public void addUser())&quot;) public void myAfter(){ System.out.println(&quot;《注解-环绕》-【单独的最终通知】&quot;); } } 开启注解对AOP的支持 &lt;aop:aspectj-autoproxy&gt;&lt;/aop:aspectj-autoproxy&gt;通过Scheme配置AOPxmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;类似于实现接口的方式 编写一个普通的类 // Schema实现的AOP不需要实现接口，只需要在xml里配置 public class LogSchema { // 前置通知 public void before(JoinPoint jp){ System.out.println(&quot;【Schema】前置通知&quot;); } //后置通知 public void afterReturning(JoinPoint jp, Object returnValue){ System.out.println(&quot;【Schema】后置通知:目标对象:&quot; + jp.getThis() + &quot;,方法名:&quot; + jp.getSignature().getName() + &quot;,参数个数:&quot; + jp.getArgs().length + &quot;, 返回值:&quot; + returnValue); } // 环绕通知 public Object around(ProceedingJoinPoint pjp){ System.out.println(&quot;【Schema】环绕-前置通知&quot;); Object result = null; try { //在此之前的为前置通知 result = pjp.proceed(); //控制目标方法是否执行 //在此之后的为后置通知 System.out.println(&quot;【Schema】环绕-后置通知:目标对象:&quot; + pjp.getThis() + &quot;,调用的方法:&quot; + pjp.getSignature().getName() + &quot;,参数个数:&quot; + pjp.getArgs().length + &quot;,返回值:&quot; + result); }catch (Throwable e){ //异常通知 System.out.println(&quot;【Schema】环绕-异常通知&quot;); } return result; } } 将该类通过配置，转为一个通知 如果要获取目标对象的信息： 注解、schema：JoinPoint 接口：Method method, Object[] args, Object target &lt;!-- 通过Schema实现AOP --&gt; &lt;bean id=&quot;logSchema&quot; class=&quot;com.test.aop.LogSchema&quot;&gt; &lt;/bean&gt; &lt;!-- 关联切入点和切面 --&gt; &lt;aop:config &gt; &lt;!-- 配置切入点 --&gt; &lt;aop:pointcut id=&quot;pcSchema&quot; expression=&quot;execution(public void com.test.service.demoService.DemoServiceImpl.addUser())&quot; /&gt; &lt;!-- 连接线 Schema方式不需要这个 &lt;aop:advisor advice-ref=&quot;logSchema&quot; pointcut-ref=&quot;pcSchema&quot; /&gt; --&gt; &lt;aop:aspect ref=&quot;logSchema&quot;&gt; &lt;!-- pointcut-ref：连接线 returnValue: 返回值 --&gt; &lt;aop:before method=&quot;before&quot; pointcut-ref=&quot;pcSchema&quot;/&gt; &lt;aop:after-returning method=&quot;afterReturning&quot; pointcut-ref=&quot;pcSchema&quot; returning=&quot;returnValue&quot;/&gt; &lt;aop:around method=&quot;around&quot; pointcut-ref=&quot;pcSchema&quot; /&gt; &lt;/aop:aspect&gt; &lt;/aop:config&gt; Spring 开发Web项目Java项目中从main开始启动，可以初始化IOC容器，在Web项目中从服务器启动时，需通过监听器初始化IOC容器 需要用到 spring-web.jar ，并在web.xml中进行配置 &lt;!-- 配置spring-web.jar 提供的监听器，可以在服务器启动时初始化IOC容器 --&gt; &lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt; &lt;/listener&gt; &lt;context-param&gt; &lt;!-- 1. 必须告诉监听器此容器的位置：context-param 2. 默认约定的位置：WEB-INF/applicationContext.xml --&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:applicationContext.xml&lt;/param-value&gt; &lt;/context-param&gt; 配置时必须告诉监听器此容器的位置，或者用默认的名称放在默认约定的位置：WEB-INF/applicationContext.xml 拆分Spring配置文件Web项目拆分配置： 三层结构 UI（html/css/jsp/servlet） Service Dao 公共 数据库 功能结构 学生管理系统的功能结构：学生相关配置、班级相关配置… Web项目合并配置： 1.在web.xml的context-param的classpath:中配置 &lt;param-value&gt; classpath:applicationContext.xml, classpath:applicationContext-1.xml, classpath:applicationContext-2.xml &lt;/param-value&gt; 或 （推荐） &lt;param-value&gt; classpath:applicationContext.xml, classpath:applicationContext-*.xml &lt;/param-value&gt;2.在主配置文件applicationContext.xml中引入其他文件 &lt;import resource=&quot;applicationContext-*.xml&quot; /&gt; ...web.xml &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot; version=&quot;4.0&quot;&gt; &lt;!-- 配置spring-web.jar 提供的监听器，可以在服务器启动时初始化IOC容器 --&gt; &lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt; &lt;/listener&gt; &lt;context-param&gt; &lt;!-- 1. 必须告诉监听器此容器的位置：context-param 2. 或者放在默认约定的位置：WEB-INF/applicationContext.xml --&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:applicationContext.xml&lt;/param-value&gt; &lt;/context-param&gt; &lt;/web-app&gt;springIOC容器与Servlet容器搭建通道，传递数据 (servlet与service)在Servlet的init初始化方法中，获取SpringIOC容器中的bean对象 ApplicationContext context = WebApplicationContextUtils.getWebApplicationContext(&quot;&quot;); xxxService = (xxxxService) context.getBean(&quot;&quot;); SpringMVCMybatisMyBatis 可以简化JDBC操作，实现数据持久化 ORM: Object Relational Mapping ORM概念：MyBatis是ORM的一个实现 / Hibernate ORM可以使得开发人员，像操作对象一样操作数据库表 开发Mybatis步骤：配置Mybatis jar包： mybatis.jar ojdbc6.jar config.xml ： 配置数据库信息 和 需要加载的映射文件 表 - 类 映射文件xxxMapper.xml ： 增删改查标签 &lt; select&gt; 测试类：sqlSession.selectOne(“需要查询的SQL的namespace.id”,”SQL的参数值”)； config.xml &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt; &lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt; &lt;!-- default和id值保持一致，通过default找到id --&gt; &lt;configuration&gt; &lt;environments default=&quot;development&quot;&gt; &lt;!-- 默认环境，即环境的id --&gt; &lt;environment id=&quot;development&quot;&gt; &lt;!-- 配置事务的提交方式： 1.用JDBC方式进行事务处理(commit rollback close) 2.MANAGER：将事务交由其他组件去托管(spring, jobss),默认会关闭连接 &lt;property name=&quot;closeConnection&quot; value=&quot;false&quot; /&gt; // 设置为不关闭 --&gt; &lt;transactionManager type=&quot;JDBC&quot;/&gt; &lt;!-- 连接方式 UNPOOLED： 传统的连接方式(每次访问数据库都需要打开和关闭等操作) POOLED： 使用数据库连接池 JNDI： 从tomcat获取一个内置的数据库连接池 --&gt; &lt;dataSource type=&quot;POOLED&quot;&gt; &lt;property name=&quot;driver&quot; value=&quot;oracle.jdbc.OracleDriver&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;jdbc:oracle:thin:@localhost:1521:ORCL&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;system&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;123456&quot;/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;mappers&gt; &lt;!-- 在配置文件中加载映射文件 --&gt; &lt;mapper resource=&quot;personMapper.xml&quot;/&gt; &lt;/mappers&gt; &lt;/configuration&gt;xxxMapper.xml &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt; &lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt; &lt;!-- namespace 映射文件路径 id 区分查询语句 resultType 返回值 parameterType 传入参数的类型，这里是id的类型int --&gt; &lt;mapper namespace=&quot;com.pojo.personMapper&quot;&gt; &lt;select id=&quot;queryPersonById&quot; resultType=&quot;com.pojo.Person&quot; parameterType=&quot;int&quot;&gt; select * from person where id = #{id} &lt;/select&gt; &lt;/mapper&gt;Mybatis的CRUD： // 加载Mybatis文件，访问数据库 Reader reader = Resources.getResourceAsReader(&quot;config.xml&quot;); // 当config.xml里的default不是所需的时，可以在build里强行切换数据库环境 SqlSessionFactory sessionFactory = new SqlSessionFactoryBuilder().build(reader, &quot;development&quot;); // SqlSessionFactory -- Connection SqlSession sqlSession = sessionFactory.openSession(); // 通过配置文件personMapper.xml里的namespace和id获得sql语句 String statement = &quot;com.pojo.personMapper.addPerson&quot;; Person person = new Person(8, &quot;cui8&quot;, 27); // insert 插入一个person int count = sqlSession.insert(statement, person); //需要 commit sqlSession.commit(); System.out.println(&quot;增加&quot; + count + &quot;个成功&quot;); sqlSession.close(); Mybatis 约定：输入参数parameterType 和 输出参数resultType，在形式上都只能有一个如果输入参数是简单类型(8个基本+String)，是可以使用任何占位符#{xxx}的；如果是对象类型，则必须是对象的属性：#{属性名}如果使用的事务方式为 jdbc，则需要手动提交：sqlSession.commit() Mybatis动态代理方式的CRUD原则：约定优于配置 硬编码方式：abc.java Configguration conf = new Configuration(); con.setName(“myProject”);配置方式：abc.xml &lt; name&gt;myProject&lt; /name&gt;约定：默认值就是myProject 具体实现步骤： jar包,config.xml ,mapper.xml… （不同处）约定的目标：省略掉Statement，即根据约定直接定位出SQL语句 1.建立一个接口PersonMapper 约定： 方法名和mapper.xml 文件中标签的id值一样 方法的输入参数类型和parameterType一样 方法的返回值和resultType一样 如： Person queryPersonById(int id); 要实现接口中的方法 和 Mapper.xml中的SQL标签一 一对应，还需要： namespace的值，就是接口的全类名(接口–mapper.xml一 一对应) 匹配的过程：（约定过程） 根据接口名 找到mapper.xml文件 （根据的是namespace=接口全类名） 根据接口的方法名 找到mapper.xml文件中的SQL标签（方法名=SQL标签id值） 根据以上两点可以保证：当调用接口中的方法时，程序能自动定位到某一个Mapper.xml文件中的SQL标签 习惯：SQL映射文件 和 接口放在同一位置(注意修改config.xml中加载mapper.xml文件的路径) 以上，可以通过接口的方法————&gt; 映射到SQL语句 // 通过约定接口的方式 PersonMapper personMapper = sqlSession.getMapper(PersonMapper.class); personMapper.updatePerson(person); // 根据接口的方法 ---&gt; 自动查找到SQL语句优化： 可以将数据库信息放入db.properties，再通过 ${key} 动态引入 &lt;configuration&gt; &lt;properties resource=&quot;db.properties&quot; /&gt; Mybatis 全局参数 //开启缓存 &lt;settings&gt; &lt;setting name=&quot;cacheEnabled&quot; value=&quot;true&quot; /&gt; &lt;setting name=&quot;&quot; value=&quot;&quot; /&gt; ... &lt;/settings&gt; 设置类的别名(忽略大小写) a. 设置单个别名 在config.xml中，&lt; typeAliases&gt; &lt; typeAlias type=”org…Person” alias=”Person” /&gt;… b. 批量设置别名，别名就是不带包名的类名 // 包名 &lt; typeAliases&gt; &lt; package name=”org.test” /&gt;… Mybatis 还内置了一些常见类的别名：_integer/_byte/_long/int/boolean… 类型处理器 (类型转换器)（将Java类型转换为JDBC类型，如int转换为oracle的number类型） a. Mybatis 自带一些常见的类型处理器 如：BooleanTypeHandler:Boolean/boolean–&gt;任何兼容的布尔值 IntegerTypeHandler：Integer/int–&gt;任何兼容的数字和整形 … b. 自定义Mybatis 类型处理器 Java类型 –&gt; 数据库（JDBC类型） 示例： 实体类Student： boolean stuSex true:男 false: 女 表student：number stuSex 1：男 0：女 自定义类型转换器(boolean – number) 步骤： a. 创建类型转换器，要实现 TypeHandler接口 或继承BaseTypeHandler（更简单）b. 在config.xml 中配置转换器 &lt;!-- 类型处理器，将java的boolean类型 转换为 jdbc的number类型 --&gt; &lt;typeHandlers&gt; &lt;typeHandler handler=&quot;com.mybatis.MyTypeHandler&quot; javaType=&quot;Boolean&quot; jdbcType=&quot;INTEGER&quot; /&gt; &lt;/typeHandlers&gt;c. 更改映射文件 &lt;!-- 验证类型转换器 1. 如果类的属性 和 表的字段类型 能够合理识别（String - varchar2），则可以使用resultType，否则使用resultMap（boolean-number） 2. 如果类的属性名 和 表的字段名 能够合理识别（String - varchar2），则可以使用resultType，否则使用resultMap（boolean-number） --&gt; &lt;select id=&quot;queryPersonByIdWithConverter&quot; resultMap=&quot;resultPerson&quot; parameterType=&quot;int&quot;&gt;select * from person where id = #{id}&lt;/select&gt; &lt;!-- 建立Person属性和表的字段的对应关系 主键id，非主键result , 再设置需要转换的类型--&gt; &lt;resultMap id=&quot;resultPerson&quot; type=&quot;person&quot;&gt; &lt;id property=&quot;id&quot; column=&quot;id&quot; /&gt; &lt;result property=&quot;sex&quot; column=&quot;sex&quot; javaType=&quot;boolean&quot; jdbcType=&quot;INTEGER&quot; /&gt; &lt;/resultMap&gt;类型转换的增加// 更改SQL语句中需要转换的字段 #{sex,javaType=boolean,jdbcType=INTEGER}注意：1. 映射文件路径 &lt;!-- 在配置文件中加载映射文件 IDEA里无法加载src下的xml文件 因此改用url class package等方式(接口与映射文件名称相同), 或将xml文件放到resources目录--&gt; &lt;!-- 通过包名设置路径 --&gt; &lt;package name=&quot;com.mybatis.myInter&quot; /&gt;2. 映射文件和config.xml的jdbcType的类型 integer 必须写成大写形式：INTEGER 5. 取值符号 简单类型 #{任意值} // 自动给String类型加上单引号’’ （自动类型转换） ${value} // 原样输出，但适合于动态排序(动态字段),其中的标识符只能是value 对象类型 #{属性名} ${属性名} SSM整合 SSM需要的jar mybatis.jar spring-tx.jar spring-jdbc.jar spring-context.support.jar spring-core.jar spring-beans.jar spring-aop.jar spring-web.jar spring-expression.ar spring-context.jar commons-logging.jar commons-dbcp.jar ojdbc.jar mybaits.jar log4.jar commons-pool.jar Mybatis需要的：类-表 Mybaits配置文件config.xml &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt; &lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt; &lt;configuration&gt; &lt;!-- 加载数据库配置文件 --&gt; &lt;properties resource=&quot;db.properties&quot;/&gt; &lt;!-- 批量设置别名 --&gt; &lt;typeAliases&gt; &lt;package name=&quot;bean&quot; /&gt; &lt;/typeAliases&gt; &lt;!-- 配置数据库环境 --&gt; &lt;environments default=&quot;development&quot;&gt; &lt;environment id=&quot;development&quot;&gt; &lt;transactionManager type=&quot;JDBC&quot; /&gt; &lt;dataSource type=&quot;POOLED&quot;&gt; &lt;property name=&quot;driver&quot; value=&quot;${driver}&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;${url}&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;${username}&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;${password}&quot;/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;!-- 加载映射文件 --&gt; &lt;mappers&gt; &lt;package name=&quot;dao&quot; /&gt; &lt;/mappers&gt; &lt;/configuration&gt; 通过mapper.xml将类、表建立映射关系 之前MyBatis使用config.xml –&gt; SqlSessionFactory，现在整合时，需要通过Spring管理SqlSessionFactory，因此 产生SqlSessionFactory不再放入config.xml，而是放入spring配置文件 使用spring整合Mybatis 目标： 通过spring产生mybatis最终操作需要的动态mapper对象 spring产生动态mapper对象有3种方法： DAO层实现类 继承 SqlSessionDaoSupport类：提供了一个属性 SqlSession ，产生mapper 扫描包方式 继续整合SpringMVC：将springmvc加入项目即可：需要spring-webmvc.jar 给项目加入springmvc支持：web.xml–&gt; dispatcherServlet 编写springmvc配置文件：applicationContext-controller.xml：视图解析器、注解驱动(基础配置、标配)]]></content>
      <categories>
        <category>spring</category>
      </categories>
      <tags>
        <tag>spring</tag>
        <tag>SSM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[oracle基础知识及命令]]></title>
    <url>%2F2019%2F09%2F07%2Foracle%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[数据字典dba_users 用户信息 dba_tablespaces 系统表空间 dba_data_files 存放表空间文件的相关信息 user_constraints 约束的相关信息管理员sys:超级管理员 sys/123456 as sysdba system:管理员 system/123456 sysman:企业级管理员 scott:用户级 scott/tiger -&gt; 修改密码为123456常用命令show user: 查看登录用户 desc table_name: 查看表（数据字典） alter user scott account [un]lock; : 锁定用户创建表create table table_name( id number(6,0), name varchar2(20), birthday date );数据类型字符型 char(n), :定长字符串，最大长度2000； nchar(n), :以unicode编码的定长字符串，最长1000； varchar2(n), :变长字符串，最大4000； 1.varchar2把所有字符都占两字节处理(一般情况下)，varchar只对汉字和全角等字符占两字节，数字，英文字符等都是一个字节；2.VARCHAR2把空串等同于null处理，而varchar仍按照空串处理；3.VARCHAR2字符要用几个字节存储，要看数据库使用的字符集，大部分情况下建议使用varchar2类型，可以保证更好的兼容性。 nvarchar2(n), :以unicode编码的变长字符串，最长2000； 数值型 number(p,s) :有效数字p位，保留s位。当s&lt;0时,表示对小数点前s位数字进行舍入。 float(n), :存储二进制的数值的，表示二进制位数0-126位，若是转化为十进制通常是乘以0.30103得到。 &gt; 一般使用number日期型date : 表示公元前4712年1月1日到公元9999年12月31日 timestamp：精确到小数位秒其他类型 blob ： 以二进制，4GB 存储 clob ： 以字符串，4GB 存储 &gt; 可存储音频、视频等修改表向表中添加字段alter table table_name add column_name datatype;修改字段类型alter table talbe_name modify column_name datatype;删除字段alter table talbe_name drop column column_name;修改字段名alter table talbe_name rename column column_name to new_name;修改表名rename talbe_name to new_table_name;删除表truncate table table_name; //删除表的内容，保留表结构，不能删除单条数据 drop talbe table_name; //删除表结构和表的内容 delete from table_name; //删除一条或多条表中数据操作表中数据添加数据insert into table_name(column_name,...) values (...); insert into table_name values (全部列...);删除数据delete from table_name [where 条件]修改数据update table_name set column_name = 值 [where 条件]查询数据select column,column from table_name; 在Oracle里执行增删改时需要进行事务的提交或回滚(回滚到上一次提交的地方) 表空间 概念：表空间是数据库的逻辑存储空间。可以理解为，在数据库当中开辟的一个空间，用于存放数据库的对象。 永久表空间：数据库中要永久化存储的一些对象，如：表、视图、存储过程 临时表空间：数据库操作当中中间执行的过程，执行结束后，存放的内容会被自动释放 UNDO表空间：用于保存事务所修改数据的旧值，可以进行数据的回滚。 查看用户下面的默认表空间select default_tablespace,temporary_tablespace from dba_users where username=&apos;SYSTEM&apos;;创建表空间create [temporary] tablespace 表空间的名称 tempfile | datafile &apos;.dbf&apos; size xx M修改用户下表空间alter USER 用户名称 DEFAULT丨TEMPORARY TABLESPACE 表空间的名称;查询表空间文件信息select file_name from dba_data_files; 注意:一个用户只能有一个默认表空间，一个表空间可以有多个表空间文件。 添加数据文件alter tablespace 表空间名 add datafile &apos;数据文件名.dbf&apos; size 数据文件大小删除数据文件alter tablespace 表空间名 drop datafile &apos;数据文件名.dbf&apos;;删除表空间drop tablespace 表空间名 [including contents and datafiles];约束 定义规则 确保完整性 非空约束 在创建表时设置 create table talbe_name(column_name datatype NOT NULL,...); 在修改表时添加 //添加非空约束的字段不能有null数据存在 ALTER TABLE table_name MODIFY column_name datatype NOT NULL; 在修改表时去除 ALTER TABLE table_name MODIFY column_name datatype NULL; 主键约束 一张表只能设计一个主键约束主键约束可由多个字段构成（联合主键 or 复合主键） 创建表时设置 CREATE TABLE table_name(column_name datatype PRIMARY KEY,...); 联合约束: CONSTRAINT constraint_name PRIMARY KEY (column_name1,...) 示例： CREATE TABLE table_name( id number(6,0), username varchar2(20), CONSTRAINT pk_id_username PRIMARY KEY (id,username)//名字任意 ); 如果忘记约束名字，可在数据字段中查找： desc user_constraints;//查询约束名称和状态select constraint_name,status from user_constraints where table_name=’table_name’;//结果为 pk_id_username 修改时添加 ALTER TABLE table_name ADD CONSTRAINT constraint_name PRIMARY KEY(column_name1,...); 更改约束名称 ALTER TABLE table_name RENAME CONSTRAINT old_constraint_name TO new_name; 禁用约束(通用） ALTER TABLE table_name DISABLE | ENABLE CONSTRAINT constraint_name; 删除主键约束（通用） ALTER TABLE table_name DROP CONSTRAINT constraint_name; ALTER TABLE table_name DROP PRIMARY KEY [CASCADE]; //CASCADE在级联操作中使用外键约束 在创建表时设置外键约束（列级） CREATE TABLE table1(column_name datatype REFERENCES table2(column_name),...); //table2为主表，table1为从表 设置外键约束时，主表字段必须为该表的主键字段 主从表中相应的字段必须时同一个数据类型 从表中外键字段的值必须来自主表中相应字段的值，或为null 在创建表时设置外键约束（表级） CREATE TABLE table_name( column_name datatype,..., CONSTRAINT constraint_name FOREIGN KEY (column_name) REFERENCES table_name2(column_name)[ON DELETE CASCADE]); // table_name2 为主表名 // [ON DELETE CASCADE]表示级联删除 // 约束的名字也是唯一的 在修改表时 ALTER TABLE table_name ADD CONSTRAINT constraint_name FOREIGN KEY(column_name) REFERENCES table_name(column_name)[ON DELETE CASCADE] 唯一约束与主键约束的区别： 主键约束的字段为非空的，而唯一约束只允许有一个值为null 单一的唯一约束中Null是未知，比较的结果依旧是未知的，顾可以存在多个null值 一张表只能有一个主键约束，但可以有多个唯一约束 创建表时设置（列级） CREATE TABLE table_name(column_name datatype UNIQUE,...); 创建表时设置（表级） CREATE TABLE table_name(column_name datatype,..., CONSTRAINT u_name UNIQUE (column_name) ); //若想设置多个唯一约束字段，可重复 CONSTRAINT 语句 修改表时添加 ALTER TABLE table_name ADD CONSTRAINT constraint_name UNIQUE (column_name); 检查约束 在创建表时（列级） CREATE TABLE table_name(column_name datatype CHEC(expressions),...); 在创建表时（表级） CREATE TABLE table_name( column_name datatype,..., CONSTRAINT c_name CHECK(expressions) ); 在修改表时 ALTER TABLE table_name ADD CONSTRAINT constraint_name CHECK(expressions);约束总结 1.在修改表的时候修改约束，只有非空约束不同，使用的是修改字段的语句： ALTER TABLE table_name MODIFY column_name datatype NOT NULL; 其他都是使用 ALTER TABLE table_name ADD CONSTTRAINT constraint_name CHECK/PRIMARY KEY /UNIQUE //外键 ADD CONSTRAINT FOREIGN KEY (column_name) REFERENCES 主表名(主表字段); 2.非空约束没有名字，其他都可以改名字 ALTER TABLE table_name RENAME CONSTRAINT old_constraint_name TO new_name;查询的时候使用数据字典：user_constraints select constraint_name,constraint_type,status from user_constraints where table_name=&apos;AAA&apos;; 3.删除约束，非空约束也是使用修改字段的语句，其他都是使用下面的： 1.禁用约束：ALTER TABLE table_name DISABLE | ENABLE CONSTRAINT constraint_name; 2.直接删除：ALTER TABLE table_name DROP CONSTRAINT constraint_name;主键约束有一种特殊的删除方法： ALTER TABLE table_name DROP PRIMARY KEY; 查询查询表中所有字段及指定字段：1.查询所有： select * from table_name;2.查询指定字段： select column,... from table_name;给字段设置别名： select coulumn 别名,column 别名 from table_naem;\对查询结果进行排序 在分组函数查询语句中进行排序，可以用order by后跟 分组函数，或跟别名，或用列数字 select coulumn... from table_name order by column_name ASC|DESC; sqlplus的另一个小技能：a命令(单词append的缩写，表示追加)当我们想在一个语句之后加上一个语句时，就好像图中我想在最后加上一个desc，以便降序排列那么我们可以直接在输入界面输入a desc（注意必须得是两个空格或两个空格以上）然后输入/再按回车执行就可以了 连接查询内连接：select * from emp,dept where emp.deptno=dept.deptno; select * from emp INNER JOIN dept ON emp.deptno=dept.deptno;外连接：// + 在左边为右外连接，在右边为左外连接 select * from emp,dept where emp.deptno+=dept.deptno; select * from emp LEFT JOIN dept ON emp.deptno=dept.deptno;运算和表达式逻辑运算的优先级： 按not、and、or的顺序依次递减； 比较运算符的优先级高于逻辑运算符。 字符串连接操作符：|| NULL操作：记录中缺少的数据值就是NULL，是指未赋值、未知或不可用的值。不等于0或空格。查询条件中使用 IS [NOT] NULL继续查询模糊查询： 通配符：_ , % 一个_只能代表一个字符，一个%可以代表0到多个任意字符 使用LIKE查询 范围查询 between...and：闭合区间的范围 IN/NOT IN：具体的值集合运算： INTERSECT(交集):返回两个查询共有的记录 UNION ALL(并集)：返回各个查询的所有记录，包括重复记录 UNION(并集)：返回各个查询的所有记录，不包括重复记录 MINUS(补集)：返回第一个查询检索出的记录减去第二个查询检索出的记录之后的剩余记录注意：使用集合操作时，查询所返回的列数以及列的类型必须匹配，列名可以不同 case…when语句CASE column_name WHEN value1 THEN result1,...[ELSE result] END CASE WHEN column_name=value1 THEN result1,...[ELSE result] END case...when 语句的使用([when后面跟的是判断的条件，then是条件为真是显示出来的东西]) decode:与case...when类似 decode(列名，判断条件，条件为真的值，默认值) decode(col_name,value1,result1,...,defaulvalue)分组查询分组函数 分组函数作用于一组数据，并对一组数据返回一个值 常用分组函数：AVG、SUM、MAX、MIN、COUNT(计数)、WM_CONCAT(行转列) 分组函数和空值:分组函数会不计算空值，想要计算空值的办法就是使用nvl()函数 ：NVL(表达式1，表达式2) 如果表达式1为空值，NVL返回值为表达式2的值，否则返回表达式1的值。该函数的目的是把一个空值（null）转换成一个实际的值。其表达式的值可以是数字型、字符型和日期型。但是表达式1和表达式2的数据类型必须为同一个类型。 分组函数会自动忽略空值 NVL函数：NVL函数使分组函数无法忽略空值 分组数据group by 子句：可将表中数据分成若干组 注意： 在SELECT列表中所有未包含在组函数中的列都应该包含在GROUP BY子句中 过滤分组：having子句的使用where与having的区别： having是先分组再过滤 。where是先过滤再分组 不能在where子句中使用组函数 可以在having子句中使用组函数 从SQL优化角度，尽量使用where，会使得分组记录数大大降低，从而提高效率 group by语句增强select deptno,job,sum(sal) from emp group by rollup(deptno,job) 意思是先以deptno job分组计算薪资再以dept分组计算薪资，再无条件分组计算薪资等价于 select deptno,job,sum(sal) from emp group by deptno,job select deptno,sum(sal) from emp group by deptno select sum(sal) from emp group by null break on deptno skip 2 //表示不同的部门号只显示一次 并且空两行 set pagesize 30 设置页面大小]]></content>
      <categories>
        <category>oracle</category>
      </categories>
      <tags>
        <tag>oracle</tag>
        <tag>sql</tag>
        <tag>DataBase</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo博客命令]]></title>
    <url>%2F2019%2F09%2F07%2Fhexo%2F</url>
    <content type="text"><![CDATA[常见的hexo命令$ hexo generate (hexo g) 生成静态文件 $ hexo server (hexo s) 启动本地服务 $ hexo deploy (hexo d) 提交到远程仓库 $ hexo new page &quot;xx&quot;(hexo n page) 创建页面 $ hexo new &quot;xx&quot; (hexo n &quot;&quot;) 创建文章 $ hexo d -g 生成静态并提交到远程仓库 $ hexo s -g 生成静态文件并启动本地预览 $ hexo clean 清除本地 public 文件安装hexo(通过git工具依次执行)$ npm install hexo-cli -g $ hexo init blog $ cd blog $ npm install $ hexo serverhexo根目录node_modules npm 文件缓存目录 scaffolds 文夹件下存放的是文章、页面模版 scource 文夹件下存放的是我们的资源文件 themes 文件下存放的是我们的主题文件 .gitignore git 忽略文件，设置提交文件时，哪些文件不提交 _config.yml 站点配置文件 package.json 站点版本，站点依赖文件 yarn.lock yarn.lock 文件由 Yarn 自动创建，并且完全通过 Yarn 进行操作。]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>blog</tag>
        <tag>github</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript基础知识]]></title>
    <url>%2F2019%2F09%2F07%2FJavaScript%2F</url>
    <content type="text"><![CDATA[JavaScript1.JavaScript简介1.JavaScript 基于对象的脚本语言 解释执行 代码以纯文本的形式存储 类型宽松，不必显示定义变量的数据类型 Netscape公司和Sun公司联手完成 2.JavaScript的功能 数据验证 表单 网页修饰和特效 导航系统 基本数学运算 动态文档生成 3.JavaScript的特点 脚本编写：小程序段方式实现编程，是解释性语言 基于对象：把页面中的各个元素看作对象 简单：基本语句和控制简单，变量为弱类型 安全：不允许访问本地硬盘，只能实现信息浏览或动态交互 动态：可以直接对客户的输入做出响应，事件驱动 跨平台：依赖于浏览器本身，与操作环境无关 4.嵌入使用 在HTML中嵌入JavaScript： 在页面中 &lt;script type=&quot;text/javascript&quot;&gt;...&lt;/script&gt; 在标记中 响应标记的某个事件 引入外部的JavaScript代码 &lt;script src=&quot; .js&quot;&gt;&lt;/script&gt; 1、在HTML页面中嵌入script代码2、language属性：定义脚本语言，一般设置为JavaScript，从HTML4.0开始，已经淘汰language属性，可以不写3、type属性：用于指定脚本语言和Internet内容类型，一般设置为 text/javascript。注意，旧版本浏览器不支持type属性4、HTML推荐将&lt;script&gt; 标记放在标记中,浏览器执行HTML页面的过程是自上而下的线性过程 2.JavaScript基本语法1.语法 区分大小写 变量是弱类型：变量在使用前不需要声明，而是解释器在运行时检查其数据类型 行结尾加分号 大括号表明代码块：使用大括号括住多条语句形成一个语句块 注释与Java、C和PHP语言的注释相同 在浏览器中逐条解释执行，如果某条语句出现错误，后面的语句将不能执行 2.常量、变量 JavaScript中没有常量概念，通常指直接在代码中给定值 var a = 123; var b = &quot;123&quot;; 变量：保存程序中的临时值，可被后面的脚本使用，变量是弱类型的 变量声明： var m; var m = &quot;123&quot;; var m, n=123; //同时声明多个变量(不建议) 可以重复声明变量，但应该尽量避免 可以直接使用变量，不声明；但应该尽量避免 变量的命名： 以字母、下划线（_）或美元符号（$）开头 余下的字符可以是下划线、美元符号或任何的字母、数字 最长为255个字符 不能有空格，大小写敏感 不能使用JavaScript中的关键字或保留字命名 JavaScript的保留字： break, delete, function, return, typeof, case, do, if, switch, var,catch, else, in, this, void, continue, false, instanceof, throw, while, debugger, finally, new, true, with, default, for, null, tryabstract, double, goto, native, static, boolean, enum, inplements,package, super, byte, export, import, private, synchronized, char,extends, int ,protected, throws, class, final, interface, public,transient, const, float, long, short, volatile delete 运算符 从对象中删除一个属性，或从数组中删除一个元素JavaScript中instanceof运算符是返回一个 Boolean 值，指出对象是否是特定类的一个实例。typeof一般只能返回如下几个结果： number,boolean,string,function,object,undefined With:这个是开域语句, 表示在with语句中的任何表达式的所属对象或者是类都由with后紧跟的变量所代表 变量类型： Undefined：未定义类型（变量值为undefined），任何未被赋值的变量；声明的变量未初始化时，该变量的初始值是undefined. String：用””或者’’括起来的字符或数值 Boolean：变量值为true或false Null空类型：用于尚未存在的对象 Number数字类型：（特殊值NaN非数）， Infinity正无穷大 -Infinity负无穷大 NaN（Not a Number） 不能用于算术计算 它与自身不相等 函数isNan() 类型转换 字符串–&gt;数值 parseInt(var) parseFloat(var) Number(var) parseInt方法和parseflota方法: 只有对string类型调用这些方法，它们才能正确运行；对其他类型都返回NaN;注：NaN 指示某个值是不是数字值。 parseInt方法首先检查位置0处的字符，判断它是否是个有效数字，若有效，再往下检查，直到发现非数字，并返回前面的检查结果。 首先，概念上 Number是一个对象Number()是这个对象的构造方法。 parseInt是一个方法，能直接写parseInt是因为它是window对象的一个方法，window可以省略。 其次，用法上 Number()只有一个参数，可以是一个字符串，也可以是其他对象（如楼上），这个要看脚本解释器（IE？）对于这个参数的处理方法。 window.parseInt()有两个参数，后一个可选，前一个是字符串，后一个是进制的位权（？是叫这个吧） 其实Number的用法应该是new Number(“2”); typeof运算符 对变量或值调用typeof运算符将返回下列的值之一 undefined” 变量是undefined类型的“boolean” 变量是boolean类型的“number” 变量是number型的“string” 变量是string型的“object” 变量是一种引用类型或null“function” 变量是一个函数 typeof(null)：返回object，这本来是JavaScript早期的bug，但后来却被写入了ECMAScript标准，可以理解为null是object的占位符。 异常捕获 目前我们可能得到的系统异常主要包含以下6种:EvalError: raised when an error occurs executing code in eval()RangeError: raised when a numeric variable or parameter is outside of its valid rangeReferenceError: raised when de-referencing an invalid referenceSyntaxError: raised when a syntax error occurs while parsing code in eval()TypeError: raised when a variable or parameter is not a valid typeURIError: raised when encodeURI() or decodeURI() are passed invalid parameters上面的六种异常对象都继承自Error对象。他们都支持以下两种构造方法: new Error(); new Error(“异常信息”); 手工抛出异常的方法如下： try { throw new Error(“Whoops!”); } catch (e) { alert(e.name + “: “ + e.message); } 如要判断异常信息的类型，可在catch中进行判断： try { foo.bar(); } catch (e) { if (e instanceof EvalError) { alert(e.name + “:” + e.message); } else if (e instanceof RangeError) { alert(e.name + “: “ + e.message); } // etc } Error具有下面一些主要属性：description: 错误描述 (仅IE可用).fileName: 出错的文件名 (仅Mozilla可用).lineNumber: 出错的行数 (仅Mozilla可用).message: 错误信息 (在IE下同description)name: 错误类型.number: 错误代码 (仅IE可用).stack: 像Java中的Stack Trace一样的错误堆栈信息 (仅Mozilla可用). 3.函数 完成某个功能的一组语句，把常用的功能写成一个函数 定义函数 function关键字 函数名称 参数列表 函数体 1.argument对象 函数可以接受任意个数的参数，通过arguments来访问 function SayHi(){ if(arguments[0] ==&quot;bye&quot;){ return; } alert(arguments[0]); } 调用： //调用形式1： &lt;script language=&quot;javascript&quot;&gt; SayHi(&quot;test&quot;); &lt;/script&gt; // 调用形式2： &lt;script language=&quot;javascript&quot;&gt; SayHi(&quot;test”,123); &lt;/script&gt; 还可以在函数内使用argument.length属性检测参数个数 function HowManyArgs(){ alert(arguments.length); } 利用arguments对象判断传递给函数的参数个数，即可模拟函数重载。2.函数的调用 普通调用：myFunction(arg1, arg2) 无参数调用:myFunction()。跟参数没有关系，会找最后定义的函数 链接调用: &lt;a href=&quot;javascript:myFunction()&quot;&gt;调用函数myFunction&lt;/a&gt; 事件触发调用：由事件触发调用函数 其它内部函数 Number()、parseInt()、parseFloat() 将数字字符串转换为数字 如果转换失败，则返回“NaN” isNaN() 判断是否不是数字 eval() 把字符串当作JavaScript表达式来执行 eval(“2+3”) 注意：var a=“aaaa”; 那么parseInt(a)返回NaN； 如果a=“2aaa”，则parseInt(a)返回2；首位不是数字就返回NaN。 在Javascript中Eval函数的使用？【eval()函数】JavaScript有许多小窍门来使编程更加容易。其中之一就是eval()函数，这个函数可以把一个字符串当作一个JavaScript表达式一样去执行它。举个小例子：var the_unevaled_answer = “2 + 3”;var the_evaled_answer = eval(“2 + 3”);alert(“the un-evaled answer is “ + the_unevaled_answer + “ and the evaled answer is “ + the_evaled_answer);如果你运行这段eval程序, 你将会看到在JavaScript里字符串”2 + 3”实际上被执行了。所以当你把the_evaled_answer的值设成 eval(“2 + 3”)时, JavaScript将会明白并把2和3的和返回给the_evaled_answer。这个看起来似乎有点傻，其实可以做出很有趣的事。比如使用eval你可以根据用户的输入直接创建函数。这可以使程序根据时间或用户输入的不同而使程序本身发生变化，通过举一反三，你可以获得惊人的效果。在实际中，eval很少被用到，但也许你见过有人使用eval来获取难以索引的对象。文档对象模型（DOM)的问题之一是:有时你要获取你要求的对象简直就是痛苦。例如，这里有一个函数询问用户要变换哪个图象:变换哪个图象你可以用下面这个函数：function swapOne(){var the_image = prompt(“change parrot or cheese”,””);var the_image_object;if (the_image == “parrot”) { the_image_object = window.do&gt; cument.parrot; } else {the_image_object = window.document.cheese;}the_image_object.src = “ant.gif”;}连同这些image标记:[img src=”/stuff3a/parrot.gif” name=”parrot”][img src=”/stuff3a/cheese.gif” name=”cheese”]请注意象这样的几行语句： the_image_object = window.document.parrot; 它把一个图象对象敷给了一个变量。 虽然看起来有点儿奇怪，它在语法上却毫无问题。 但当你有100个而不是两个图象时怎么办？你只好写上一大堆的 if-then-else语句，要是能象这样就好了： function swapTwo(){ var the_image = prompt(“change parrot or cheese”,””); window.document.the_image.src = “ant.gif”; } 不幸的是, JavaScript将会寻找名字叫 the_image而不是你所希望的”cheese”或者”parrot”的图象，于是你得到了错误信息： ”没听说过一个名为the_image的对象”。 还好，eval能够帮你得到你想要的对象。 function simpleSwap(){ var the_image = prompt (“change parrot or cheese”,””); var the_image_name = “window.document.” + the_image; var the_image_object = eval(the_image_name); the_image_object.src = “ant.gif”; } 如果用户在提示框里填入”parrot”，在第二行里创建了一个字符串即window.document.parrot. 然后包含了eval的第三行意思是： “给我对象window.document.parrot” - 也就是你要的那个图象对象。一旦你获取了这个图象对象，你可以把它的src属性设为ant.gif. 有点害怕？用不着。其实这相当有用，人们也经常使用它。我们常常在Javascript中间到Eval这个函数，有些人觉得这个函数很奇怪，可以把一些字符串变的功能很强大在我们需要将普通的字符串转变成具体的对象的时候，就会用到这个函数eval 函数对作为数字表达式的一个字符串进行求值，其语法为：eval(expr)此处 expr 是一个被求值的字符串参数。如果该字符串是一个表达式，eval 求该表达式的值；如果该参数代表一个或多个 JavaScript 语句，那么 eval 执行这些语句。eval 函数可以用来把一个日期从一种格式（总是字符串）转换为数值表达式或数字。 4. 对象 对象是属性和方法的组合 属性是对象所拥有的一组外观特征，一般为名词 方法是对象可以执行的功能，一般为动词 1、JavaScript中分为三种对象： 1）浏览器对象：浏览器窗口window、文档 document、url地址等 2）脚本对象： String字符串对象、Date日期对象、Math数学对象等 3）HTML对象：各种HTML标记:、段落&lt;P&gt;、图片、超链接&lt;A&gt;等 2. 对象创建及废除 对象创建 使用new关键字来创建对象 var oObject = new Object(); 如果构造函数无参数，则不必加括号 对象废除 不必专门销毁对象来释放内存 当没有针对该对象的引用时，被自动废除 把对象的所有引用设置为null时也可以废除对象 在ECMAScript中有无用存储单元收集程序 JavaScript不必专门销毁对象来释放内存 当再没有针对某对象的引用时，该对象被废除 把对象的所有引用设置为null，可以强制废除对象 当运行无用存储单元收集程序时，所有废除对象都被销毁 3. JavaScript内部对象 Array Date Math String Array对象: 数组是一组变量的有序集合 通过数组索引来使用一个变量 创建数组 新建一个长度为0的数组 var array_name = new Array(); 长度为100的数组 var array_name = new Array(100); 新建一个指定长度的数组，并赋初值 var array_name = new Array(“red”,”green”,1,2,3); JavaScript中的数组长度不固定，赋值即可改变长度（动态） Array对象的常用方法: concat: 返回一个新数组；由两个或者更多数组组合而成 var newArray = tmpArray.concat(tmpArray)join: 返回字符串；由数组中的所有元素连接到一起，元素间的间隔符由参数指定，省略参数则用逗号分隔 var newString = tmpArray.join(“.”)reverse: 返回一个新数组；由原来的数组反转而成 var newArray = tmpArray.reverse();pop:移除数组中的最后一个元素并返回该元素var newString = tmpArray.pop()push:给数组中增加新元素，并返回数组的新长度var newLength = tmpArray.push(“a”,”b”)shift:移除数组中的第一个元素并返回该元素var newString = tmpArray.shift() Date对象： 可以用来表示任意的日期和时间，获取当前系统日期以及计算两个日期的间隔 给出星期、月份、天数、年份、小时、分钟和秒表示的时间 要使用new运算符创建一个新的Date对象 NONE（空）:创建当前日期对象 yyyy, mm, dd :根据年月日来创建日期对象yyyy, mm, dd, hh, mm, ss, ms :根据年月日时分秒创建日期对象yyyy/mm/dd :根据年月日创建日期对象 注意：使用new Date(“2004/7/4”)时，一定要加引号，否则认为是毫秒数 Date方法： Date没有直接访问的属性，只有获取和设置的方法 获取日期和时间的方法 getYear()：返回年数；（小于2000年返回两位） getFullYear()：返回年数； getMonth()：返回当月号数；（比实际小1） getDate()：返回当日号数； getDay()：返回星期几；（0表示星期日） getHours()：返回小时数； getMinutes()：返回分钟数； getSeconds()：返回秒数； getTime()：返回毫秒数； 设置日期和时间的方法 setYear()：设置年数； setMonth()：设置当月号数；（set7表示8月） setDate()：设置当日号数； setDay()：设置星期几； setHours()：设置小时数； setMinutes()：设置分钟数； setSeconds()：设置秒数； setTime()：设置毫秒数； 1、JavaScript自1970年1月1日以来一直以毫秒的形式在内部存储日期2、在读取当前日期和时间时，代码依赖的是客户机的时钟，如果客户机的时间有误，代码会如实反映3、星期的天数以及年的月数是从0开始的。因此，第0天是星期日，第6天是星期六；第0月是1月。但是每月的天数是从1开始计数的4、Date对象的setDate、setMonth方法的参数可以为负值，会导致从年或者月借位 Date的To方法： toGMTString：使用格林威治标准时间(GMT) 数据格式将 Date 对象转换成字符串表示 toLocaleString： 使用当地时间格式将 Date 对象转换成字符串表示 Date的Parse和UTC方法： Date.parse (date string )：用日期字符串表示自 1970 年 1 月 1 日以来的毫秒数 Date.UTC (year, month, day, hours, min, secs)：Date 对象中自 1970 年 1 月 1 日以来的毫秒数 toLocaleString:2019/1/9 下午5:16:01toDateString:Wed Jan 09 2019toLocaleDateString: 2019/1/9toLocaleTimeString: 下午5:16:01Date: Tue Mar 19 2019 00:00:00 GMT+0800 (中国标准时间)Date.parse: 1547025361000Date.UTC: NaN Date.parse()方法解析一个包含日期的字符串，并返回该日期与 1970 年 1 月 1 日午夜之间所间隔的毫秒数。注意:1、短日期可以使用“/”或“-”作为日期分隔符，但是必须用月/日/年的格式来表示，例如”7/20/96”。2、年份值可以用 2 位数字表示也可以用 4 位数字表示。如果使用 2 位数字来表示年份，那么该年份必须大于或等于 70。如果传递给parse的参数不能解析成不能转换成字符串，则返回NaN Date.UTC() 方法的参数指定日期和时间，它们都是 UTC 时间，处于 GMT 时区。指定的 UTC 时间将转换成毫秒的形式，这样构造函数 Date() 和方法 Date.setTime() 就可以使用它了。Date.UTC()方法Date.UTC(year,month,date[,hours][,minutes][,seconds][,ms])year 必选项。完整的年份，比如，1976（而不是 76）。month 必选项。表示的月份，是从 0 到 11 之间的整数（ 1 月至 12 月）。date 必选项。 表示日期，是从 1 到 31 之间的整数。hours 可选项。 如果提供了 minutes 则必须给出。表示小时，是从 0 到 23 的整数（午夜到 11pm）。minutes 可选项。如果提供了 seconds 则必须给出。表示分钟，是从 0 到 59 的整数。seconds 可选项。如果提供了 milliseconds 则必须给出。表示秒钟，是从 0 到 59 的整数。ms 可选项。 表示毫秒，是从 0 到 999 的整数。 Math对象： 全局对象 使用时不需要创建实例 Math对象的属性: LN10 : 10的自然对数 PI : 3.1415926… SQRT1_2 : 1/2的平方根(根号2除以2) Math对象的方法： 1、Math.abs(number) 返回数字的绝对值2、Math.ceil(number) 返回大于等于其数字参数的最小整数。 ps:琢磨半天，感觉像进位取整。3、Math.floor(number)返回小于等于其数值参数的最大整数。 ps:就是个取整。4、Math.max() 返回给出的零个或多个数值表达式中较大者。5、Math.min() 返回给出的零个或多个数值表达式中较小的值。6、Math.random() 产生的伪随机数介于 0 和 1 之间（含 0，不含 1)7、Math.round(number) 说白了就是四舍五入8、Math.sqrt(number) 返回平方根 String对象： 和原始字符串类型对应的内置对象 声明字符串： var string_name = “string of text”; var string_name = new String(“string of text”)属性： length：返回String对象的长度 constructor 属性，表示创建对象的函数。 x = new String(&quot;Hi&quot;); if (x.constructor == String) // 进行处理（条件为真） 方法： charAt(i) ： 返回指定索引位置处的字符 charCodeAt(i) ： 返回一个整数，代表指定位置上字符的 Unicode 编码 concat(str) ： 连接字符串 indexOf(str) ： 返回 String 对象内第一次出现子字符串的字符位置（注意：从左至右查找，返回整数值） lastIndexOf(str) ： 返回 String 对象中子字符串最后出现的位置 replace(str1,str2) ： 返回将str1替换为str2后的字符串 slice(start,end) ： 返回字符串中起始位置为start,结束位置为end(不包括end)的子字符串 split(separator, limit) ： 将字符串以separator作为分割符切割成多个子字符串，并将他们作为一个数组返回；如果有limit参数则返回数组的limit个元素 substr(start,length) ： 返回一个从指定位置开始的指定长度的子字符串 substring(start,end) : 返回一个指定位置之间的子字符串，不包括end toLowerCase : 返回一个字符串，字符串中的字母被转换为小写字母 toUpperCase : 返回一个字符串，字符串中的字母被转换为大写字母 stringObject.slice(start,[end])和stringObject.substring(start,[end])方法都接受两个参数，分别为子字符串的起始位置和终止位置，返回这两者之间的字符串，不包括终止位置的那个字符串。如果不指定第二个参数，则默认为字符串的长度，即从起始位置到字符串的末尾。 【区别】这两个方法的区别主要是对于负数的处理不同。负数参数对于slice()而言是从字符串的末尾往前计数，而substring()则直接将负数忽略，作为0来处理，并将0作为起始位置，正数作为终止位。例如：substring(2,-3)等同于substring(0,2) 4. 定义对象 在JavaScript中可以使用构造函数Object()来创建自己的对象 var newObject = new Object; 定义类或对象的五种方式：第一种方式： 工厂方法 能创建并返回特定类型的对象的工厂函数（factory function）。 function createCar(sColor){ var oTempCar = new Object; oTempCar.color = sColor; oTempCar.showColor = function (){ alert(this.color); }; return oTempCar; } var oCar1 = createCar(); var oCar2 = createCar(); 调用此函数时，将创建新对象，并赋予它所有必要的属性。使用此方法将创建car对象的两个版本（oCar1和oCar2），他们的属性完全一样。使用此方法存在的问题： 语义上看起来不像使用带有构造函数的new运算符那么正规。 使用这种方式必须创建对象的方法。每次调用createCar()，都要创建showColor()，意味着每个对象都有自己的showColor()版本，事实上，每个对象都共享了同一个函数。 有些开发者在工厂函数外定义对象的方法，然后通过属性指向该方法。从而避免这个问题： function createCar(sColor){ var oTempCar = new Object; oTempCar.color = sColor; oTempCar.showColor = showColor; return oTempCar; } function showColor(){ alert(this.color); } 在这段重写的代码中，在函数createCar()前定义了函数showColor().在createCar()内部，赋予对象一个已经指向已经存在的showColor()函数的指针。从功能上来讲，这样解决了重复创建对象的问题，但该函数看起来不像对象的方法。所有这些问题引发了开发者定义的构造函数的出现。 第二种方式：构造函数方式 function Car(sColor){ this.color = sColor; this.showColor = function (){ alert(this.color); }; } var oCar1 = new Car(&quot;red&quot;); var oCar2 = new Car(&quot;blue&quot;); 你可能已经注意到第一个差别了，在构造函数内部无创建对象，而是使用this关键字。使用new运算符调用构造函数时，在执行第一行代码前先创建一个对象，只有用this才能访问该对象。然后可以直接赋予this属性，默认情况下是构造函数的返回值（不必明确使用return运算符）。这种方式在管理函数方面与工厂方法一样都存在相同的问题。 第三种方式：原型方式 function Car(){ } Car.prototype.color = &quot;blue&quot;; var oCar1 = new Car(); var oCar2 = new Car(); 调用new Car()时，原型的所有属性都被立即赋予要创建的对象，意味着所有的Car实例存放的都是指向showColor()函数的指针。从语义上看起来都属于一个对象，因此解决了前面两种方式存在的两个问题。此外使用该方法，还能用instanceof运算符检查给定变量指向的对象类型。因此，下面的代码将输出true： alert(oCar instanceof Car); //outputs “true” 这个方式看起来很不错，遗憾的是，它并不尽如人意。 首先这个构造函数没有参数。使用原型方式时，不能给构造函数传递参数初始化属性的值，因为car1和car2的属性都等于“red”。 真正的问题出现在属性指向的是对象，而不是函数时。函数共享不会造成任何问题，但是对象却很少被多个实例共享的。 第四种方式：混合的构造函数/原型方式（推荐) 联合使用构造函数和原型方式，就可像用其他程序设计语言一样创建对象。这种概念非常简单，即用构造函数定义对象的所有非函数属性，用原型方式定义对象的函数属性（方法）。 function Car(sColor){ this.color =sColor; this.drivers =new Array(&quot;Mike&quot;,&quot;Sue&quot;); } Car.prototype.showColor = function(){ alert(this.color); } var oCar1 =new Car(&quot;red&quot;); var oCar2 =new Car(&quot;blue&quot;); oCar1.drivers.push(&quot;Matt&quot;); alert(oCar1.drivers); //outputs &quot;Mike,Sue,Matt&quot; alert(oCar1.drivers); //outputs &quot;Mike,Sue&quot; 第五种方式：动态原型方式（推荐 对于习惯使用其他语言的开发者来说，使用混合的构造函数/原型方式感觉不那么和谐。批评混合的构造函数/原型方式的人认为，在构造函数内找属性，在外部找方法的做法很不合理。所以他们设计了动态原型方式，以提供更友好的编码风格。动态原型方法的基本想法与混合的构造函数/原型方式相同，即在构造函数内定义非函数属性，而函数属性则利用原型属性定义。唯一的区别是赋予对象方法的位置。下面是使用动态原型方法重写的Car类： function Car(sColor){ this.color =sColor; this.drivers =new Array(&quot;Mike&quot;,&quot;Sue&quot;); if(typeof Car._initialized == &quot;undefined&quot;){ Car.prototype.showColor = function(){ alert(this.color); } } Car._initialized = true; } 5. 操作对象 使用with语句： 在with语句体内，任何对变量的引用都被认为是这个对象的属性 with(object){直接使用对象的属性/方法} 如： //默认： document.write(Math.cos(35)); //使用with： with (Math){ document.write(cos(35)); document.write(sin(35)); } 5. 对象模型 浏览器对象模型-BOM(Browser Object Model) 提供独立于内容而与浏览器窗口进行交互的对象 window对象的属性： document frames history location navigator screen document对象的属性： anchors forms images links location Window对象： 观察BOM的体系结构，所有的对象都源自window对象，它表示整个浏览器窗口。Frame实际是个array，如果窗口分祯的话，每个frame相当一个单独的window对象，如window.frames[0]（注意，top对象的使用，top永远指向最外层的祯，top.frames[0], 因为当你的代码被包括在某个frame中是，这时候window指向的是当前祯，这也许不是你的原意，所以尽量使用top来避免错误 parent ，self，top，window的关系： parent：如果当前窗口为frame，指向包含该frame的窗口的frame （frame） self ：指向当前的window对象，与window同意。 （window对象） top ：如果当前窗口为frame，指向包含该frame的top-level的window对象 window ：指向当前的window对象，与self同意。 window的有用属性/对象与方法: 大小与移动： moveBy，moveTo，resizeBy，resizeTo; 打开popup窗口： open； 系统提示窗： alert(),confirm(),prompt； 状态栏： Status，defaultStatus； 时间间隔： setTimeout()，setInterval； 历史纪录: history.go(-1) //后退 document对象: 唯一BOM和DOM都有的对象。从BOM的角度看，侧重于从集合的角度看问题，把页面划分为不同的部分，以及页面本身的一些属性，如背景色，标题名称等，由于BOM的实现是基于浏览器的，所以不同浏览器的属性和方法有不一致之处，这造成很多麻烦。注意一些一致的，常用的属性和方法，BOM把页面分为如下几部分： anchors : Collection of all anchors in the page(represented by &lt;a name=”anchorname”&gt;&lt;/a&gt;) applets : Collection of all applets in the page forms : Collection od all embeded objects in the page(represented by the &lt;embed /&gt; tag) images : Collection of all forms in the page links : Collection of all links in the page (represented by &lt;a href=”somewhere.htm”&gt;&lt;/a&gt;) location 对象: 指浏览器窗口中输入的URL,它有很多属性，即把URL拆为了很多部分，分别表示之，如href，host，port，pathname等 Navigator对象:navigator是一个独立的对象，他用于提供用户所使用的浏览器以及操作系统等信息，以navigator对象属性的形式来提供。更加针对浏览器，举一些IMOS都有的例子如appCodeName，appName, userAgent等Screen对象:这个Screen指的是客户计算机的屏幕，如我的机器的Screen.Heigh和Width为768X1024，例如可以用这个属性将浏览器置为全屏：window.moveTo(0, 0);window.resizeTo(screen.availWidth, screen.availHeight);]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>JS</tag>
      </tags>
  </entry>
</search>
